[{"title":"Auth","type":0,"sectionRef":"#","url":"/concepts/auth","content":"","keywords":""},{"title":"Use Cases​","type":1,"pageTitle":"Auth","url":"/concepts/auth#use-cases","content":"Add API Auth to your endpoints to protect the entire app or individual paths or pages. Password protect components such as admin pages in the browserMicroservice backend-backend authentication "},{"title":"Route Patterns​","type":1,"pageTitle":"Auth","url":"/concepts/auth#route-patterns","content":"Use express router path syntax to define path patterns for which to enable auth with corresponding authentication schemes. This includes wildcard characters like * and ?. Read more to understand the syntax in detail. Route Patterns with Express Syntax When enabled, Auth is required on requests whenever a certain URL pattern is matched. This applies to all HTTP methods at those paths. pattern /page will enable auth at the path https://sample-app.cyclic.app/page but still allow access to other routespattern /page* will enable auth at all paths starting with /page but allow access to others, for example: auth required on /page/image.jpeg or /pages but not required on /other pattern /* will enable auth for all routes "},{"title":"Credentials​","type":1,"pageTitle":"Auth","url":"/concepts/auth#credentials","content":""},{"title":"Basic Auth Scheme​","type":1,"pageTitle":"Auth","url":"/concepts/auth#basic-auth-scheme","content":"Apps can be configured with basic username/password credentials. These credentials will be required for route patterns that specify the Basic auth scheme. In the browser, users will be prompted to enter a username and password into a prompt popup.For direct API calls to authenticated routes outside the browser: An Authorization header must be provided with the value of the username and password joined with a : and base64 encoded - Basic {base64(username:password)}. Example browser request: fetch(&quot;https://sample-app.cyclic.app/page&quot;, { &quot;headers&quot;: { &quot;Authorization&quot;: `Basic ${btoa('username:password')}`, }, &quot;method&quot;: &quot;GET&quot; }); Example Node.js request: axios.get('https://httpbin.org/get', { headers: { 'Authorization': `Basic ${Buffer.from('username:password').toString('base64')}` } }); Read more to understand basic auth in detail. "},{"title":"Limits​","type":1,"pageTitle":"Auth","url":"/concepts/auth#limits","content":"Currently only Basic auth scheme is available with others coming soonThe number of credentials is limited to 3 per appThe number of route patterns is limited to 3 per app "},{"title":"Example​","type":1,"pageTitle":"Auth","url":"/concepts/auth#example","content":"Enable auth for your app as explained above.Encode user name and password using online base64 encoder or bash: echo -n 'username:password' | base64Use base64 encoded string in Authorization header: curl -H &quot;Authorization: Basic $(echo -n 'username:password' | base64)&quot; https://app-url.cyclic.app  "},{"title":"Apps","type":0,"sectionRef":"#","url":"/concepts/apps","content":"","keywords":""},{"title":"Infrastructure​","type":1,"pageTitle":"Apps","url":"/concepts/apps#infrastructure","content":"Cyclic manages the provisioning, upgrades, instrumentation, configuration and cloud best practices to set your code up with scalable, fault tolerant, serverless infrastructure. AWS Cloud: App infrastructure is provisioned and managed as infrastructure as code (IaC) in AWS CloudFormationServerless: a cloud execution model that enables your apps to be highly scalable, they can process single requests or millions of requests on demand without having to change logic, manage clusters, tune parameters or deploy anything.Fault Tolerant: Apps have the capability to be provisioned with active-active disaster recovery strategy in all AWS regions. This means that applications can be made resilient to severe outages, limiting impact to end-users with zero downtime. "},{"title":"Hosting​","type":1,"pageTitle":"Apps","url":"/concepts/apps#hosting","content":"We describe hosting in terms of where the underlying app infrastructure is hosted. While the application code is executed on AWS Lambda compute, the Lambdas themselves can be hosted in any AWS cloud account, ours or yours. "},{"title":"Runtime​","type":1,"pageTitle":"Apps","url":"/concepts/apps#runtime","content":"The runtime is the Cyclic environment and process that manages the execution of your code. Bootstraps applications to run in a serverless Lambda environment Marshalls/unmarshalls requests and responses from port-listening applications to ApiGateway Error handling and reportingCaptures request/response pairs to and from the application codeCaptures traces and logs generated by application code "},{"title":"Code​","type":1,"pageTitle":"Apps","url":"/concepts/apps#code","content":"You bring the code by connecting a git repository to Cyclic. Code is built and deployed on git push to the default branch on GitHub. Apps are directly linked to their git repositories via webhooks that Cyclic installs. The repos must contain a package.json file to inform the build and runtime processes on how to build and start apps. "},{"title":"Build​","type":1,"pageTitle":"Apps","url":"/concepts/apps#build","content":"Cyclic follows the instructions provided in package.json scripts included in your code. The build environment is transient, all build files/memory is removed after the build. While built apps are limited to 250 MB, the build environment can support up to 10GB including dev dependencies. Cyclic will prune any devDependencies from the build directory before trying to package. Therefore move any frameworks or modules that are only needed at build time into the devDependencies section of your package.json. "},{"title":"Databases","type":0,"sectionRef":"#","url":"/concepts/database","content":"","keywords":""},{"title":"DynamoDB​","type":1,"pageTitle":"Databases","url":"/concepts/database#dynamodb","content":"An enhanced single-table database built on the fast and globally scalable DynamoDB. On top of DynamoDB NoSQL functionality and table there is a number of additional resources that enable features including: Simple Key-Value inspired SDKWrite-Time IndexingFlexible QueriesJSON Schema Discovery Local Dev When deployed Cyclic apps are directly integrated with AWS resources with no need for any additional config. When developing and interacting with AWS on local, use credentials provided on the Data / Storage tab of an app. The credentials are temporary and expire after 60 minutes. New credentials can be retrieved by reloading the page. "},{"title":"Using DynamoDB with the @cyclic.sh/dynamodb Package​","type":1,"pageTitle":"Databases","url":"/concepts/database#using-dynamodb-with-the-cyclicshdynamodb-package","content":"GitHub | NPM The sdk simplifies the DynamoDB interface and enables collection organization of records, queries and data scheme discovery among other features. "},{"title":"Collection Items​","type":1,"pageTitle":"Databases","url":"/concepts/database#collection-items","content":"The package organizes items into the following structure: { &quot;collection&quot;: &quot;animals&quot;, &quot;key&quot;: &quot;luna&quot;, &quot;props&quot;: { &quot;updated&quot;: &quot;2022-03-23T13:02:12.702Z&quot;, &quot;created&quot;: &quot;2022-03-23T12:32:02.526Z&quot;, &quot;color&quot;: &quot;orange&quot;, &quot;type&quot;: &quot;cat&quot; }, &quot;$index&quot;: [ &quot;color&quot; ] }  The key should be used to uniquely identify an item and it's set of child items. $index is a list of props by which them item will be indexed. key-value pairs that have been indexed can be used to retrieve or query items with greater performance. // example.js const CyclicDB = require('cyclic-dynamodb') const db = CyclicDB(your-app-idCyclicDB) // find it on the Database/Storage tab const run = async function(){ let animals = db.collection('animals') // create an item in collection with key &quot;leo&quot; let leo = await animals.set('leo', { type:'cat', color:'orange' }) // get an item at key &quot;leo&quot; from collection animals let item = await animals.get('leo') console.log(item) } run()  "},{"title":"Item Fragments​","type":1,"pageTitle":"Databases","url":"/concepts/database#item-fragments","content":"With the cyclic data model, items can have fragments. These can be thought of as children or attachments to items. Another way to think of fragments is by thinking of an item itself as its own collection of other items that are stored closely together. An example use case for a user record would be something like: item user: name, last name, id fragment home: address, cityfragment work: company name, position, work address Fragments objects look just like items but give you a way to better organize your data with higher query performance. let users = db.collection('users') await users.item('mike') .fragment('work').set({ company: 'cyclic' }) let mikes_work = await users.item('mike').fragment('work').get()  "},{"title":"Using DynamoDB Directly​","type":1,"pageTitle":"Databases","url":"/concepts/database#using-dynamodb-directly","content":"If you choose not to use the open source cyclic-dynamodb package, apps have CRUD access to the table and can make use of the table's generic raw schema directly. When using the table directly with AWS DynamoDB SDK or other third party SDK's, the following fields and indexes can be used: IndexName\tPartition Key\tRange Key\tProjected Fieldsprimary\tpk\tsk\tall keys_gsi\tkeys_gsi\tkeys_gsi_sk\tpk,sk, gsi_prj gsi_prj\tgsi_prj\t-\tprj The table also has several attribute names that are reserved and should not be used directly:gsi1,gsi2,gsi_s,gsi_s_sk,gsi_s2,gsi_s2_sk An additional attribute ttl is reserved and drives record expiration as specified by standard DynamoDB "},{"title":"File System","type":0,"sectionRef":"#","url":"/concepts/file_system","content":"File System The Node.js file system module gives you access to the file system on your local environment. To include the fs modules use the require() method:const fs = require('fs'); The fs method is often used for reading, creating, updating, deleting, and renaming files, however there is a long list of methods, which you can see here in the Node documentation: https://nodejs.org/api/fs.html. Files created by the fs module are read-only once the project is deployed to Cyclic.sh. This results in an EROFS: Error Read-Only File System error. If you are hitting the EROFS error in processing files, one solution is to write to a file that is located in a /tmp directory. However, do not use /tmp for perminant storage, as is it wiped frequently. A more perminant solution to this error is to use the Cyclic S3fs drop-in replacement for Node.js fs, which gives you acces to an AWS S3 bucket to access as file storage in place of your local file system. Instructions to use the @cyclic.sh/s3fs npm module can be found in the README.md for the module. Try the S3fs module.","keywords":""},{"title":"Hosting","type":0,"sectionRef":"#","url":"/concepts/hosting","content":"","keywords":""},{"title":"Cyclic-hosted​","type":1,"pageTitle":"Hosting","url":"/concepts/hosting#cyclic-hosted","content":"Cyclic manages limits and constraints as well as the access boundaries and permissions to cloud resources external to the application to maintain logical isolation of your apps. "},{"title":"Self-hosted​","type":1,"pageTitle":"Hosting","url":"/concepts/hosting#self-hosted","content":"While Cyclic still helps you manage deployments, config and features of the runtime, you have full control of the app infrastructure with access to customize, take apart and tinker. This enables use-cases like: Integration with other AWS infrastructure in your own accounts like: Connect a Cyclic app to a SageMaker modelUse Cyclic apps to produce alerts based on CloudWatch alarms Connect apps to AWS data services like S3 or Dynamo Define and enforce your own limits and constraints Apps come pre-configured with sensible defaults with respect to compute sizing and network quotas; self-hosting allows you to override Cyclic defaults Include Cyclic apps in your existing log aggregation solutionsBring Cyclic apps under your security and service control policies In your own account, you own all things IAM, permission boundaries, service roles, etc. "},{"title":"Storage","type":0,"sectionRef":"#","url":"/concepts/storage","content":"","keywords":""},{"title":"Config​","type":1,"pageTitle":"Storage","url":"/concepts/storage#config","content":"Apps running on Cyclic have environment AWS environment variables that provide for access to the app's associated S3 bucket. However, you will need to provide either a BUCKET environment variable or set the bucket name directly in your code. To access the bucket from local, go to the storage tab of the app, copy credentials and paste on your associated command line. As with running on Cyclic you will need to provide your code or cli the bucket name. "},{"title":"Cost and Limits​","type":1,"pageTitle":"Storage","url":"/concepts/storage#cost-and-limits","content":"The free tier includes: 1GB of storage per month. Additional storage is billed on a GB / month basis.10GB of data transfer to the internet per month. Additional data transfer is billed on a per GB basis. For a complete list of limits check out the limits page Example "},{"title":"Install​","type":1,"pageTitle":"Storage","url":"/concepts/storage#install","content":"npm install aws-sdk "},{"title":"Usage in Express​","type":1,"pageTitle":"Storage","url":"/concepts/storage#usage-in-express","content":"From our S3 Storage Starter const express = require('express') const app = express() const AWS = require(&quot;aws-sdk&quot;); const s3 = new AWS.S3() const bodyParser = require('body-parser'); app.use(bodyParser.json()) // curl -i https://some-app.cyclic.app/myFile.txt app.get('*', async (req,res) =&gt; { let filename = req.path.slice(1) try { let s3File = await s3.getObject({ Bucket: process.env.BUCKET, Key: filename, }).promise() res.set('Content-type', s3File.ContentType) res.send(s3File.Body.toString()).end() } catch (error) { if (error.code === 'NoSuchKey') { console.log(`No such key ${filename}`) res.sendStatus(404).end() } else { console.log(error) res.sendStatus(500).end() } } }) // curl -i -XPUT --data '{&quot;k1&quot;:&quot;value 1&quot;, &quot;k2&quot;: &quot;value 2&quot;}' -H 'Content-type: application/json' https://some-app.cyclic.app/myFile.txt app.put('*', async (req,res) =&gt; { let filename = req.path.slice(1) console.log(typeof req.body) await s3.putObject({ Body: JSON.stringify(req.body), Bucket: process.env.BUCKET, Key: filename, }).promise() res.set('Content-type', 'text/plain') res.send('ok').end() }) // curl -i -XDELETE https://some-app.cyclic.app/myFile.txt app.delete('*', async (req,res) =&gt; { let filename = req.path.slice(1) await s3.deleteObject({ Bucket: process.env.BUCKET, Key: filename, }).promise() res.set('Content-type', 'text/plain') res.send('ok').end() }) // ///////////////////////////////////////////////////////////////////////////// // Catch all handler for all other request. app.use('*', (req,res) =&gt; { res.sendStatus(404).end() }) // ///////////////////////////////////////////////////////////////////////////// // Start the server const port = process.env.PORT || 3000 app.listen(port, () =&gt; { console.log(`index.js listening at http://localhost:${port}`) })  "},{"title":"Variables","type":0,"sectionRef":"#","url":"/concepts/env_vars","content":"","keywords":""},{"title":"Setting Variables​","type":1,"pageTitle":"Variables","url":"/concepts/env_vars#setting-variables","content":""},{"title":"Local​","type":1,"pageTitle":"Variables","url":"/concepts/env_vars#local","content":"Do not put your .env file in GitHub Especially if your repo is public. Make sure to add .env file to your .gitignore. If you accidentally push your .env file to GitHub, its contents will be permanently in the repository's history - even if you delete it afterwards On local, there are many ways to get environment variables into your application. Refer to these popular packages for more info: env-cmd - https://www.npmjs.com/package/env-cmd (recommended) can be used in package.json scripts to injects variables from .env without changes to application code. For example: in dev - load local env vars from .env and watch for file changeswhen deployed, Cyclic runs start. env-cmd is not needed since variables are available automatically. This way env-cmd only has to be a devDependency ... &quot;scripts&quot;: { &quot;start&quot;: &quot;node index.js&quot;, &quot;dev&quot;: &quot;env-cmd node --watch index.js&quot; } ... tip: as of node 18, node --watch can be used to watch for file changes in place of nodemon dotenv - https://www.npmjs.com/package/dotenv sets variables from a .env file with: require('dotenv').config()  "},{"title":"Cyclic​","type":1,"pageTitle":"Variables","url":"/concepts/env_vars#cyclic","content":"Environment variables can be set after a first deployment in an app's dashboard via the Variables tab. Cyclic stores environment variables securely by encrypting them at rest, they are visible only to users that have permissions to the app environment. Changes are applied immediately Changes to environment variables are applied immediately to running apps without a re-deployment. All apps are preset with the following variables: CYCLIC_URL - the default url of the appCYCLIC_DB - the name of the AWS DynamoDB table available to the appCYCLIC_BUCKET_NAME - the name of the AWS S3 Bucket available to the appCYCLIC_APP_ID - the app environments unique id  There are two ways to set up variables: Key-Value Editor:​  Add the variable name and value with + Add Variable, then Save Bulk Editor:​  A text editor that allows you to work on multiple variables at once in a similar syntax to .env files with the exceptions: Comments are not supportedQuotes not required and are passed as part of the value VAR=&quot;MY VALUE&quot; will result in your code seeing &quot;MY VALUE&quot; rather than MY VALUEVAR instead should be set as VAR=MY VALUE "},{"title":"Accessing Variables​","type":1,"pageTitle":"Variables","url":"/concepts/env_vars#accessing-variables","content":""},{"title":"Frontend​","type":1,"pageTitle":"Variables","url":"/concepts/env_vars#frontend","content":"The frontend does not have access to environment variables Variable values often include database secrets and API keys - they should never be exposed to the frontend. "},{"title":"Backend​","type":1,"pageTitle":"Variables","url":"/concepts/env_vars#backend","content":"Application code on the backend has access to variables via process.env during runtime. "},{"title":"Build​","type":1,"pageTitle":"Variables","url":"/concepts/env_vars#build","content":"Environment variables that are set for the runtime are also accessible to the scripts defined in package.json Support for variables in first deployment Support for setting environment variables before a first deployment is coming soon. Currently, as a workaround - consider modifying your build step to pass. This will allow you to use the app dashboard to add variables. Once added, revert your build scripts to their original state. Variables will be available for all subsequent builds. "},{"title":"Reserved Environment Variables​","type":1,"pageTitle":"Variables","url":"/concepts/env_vars#reserved-environment-variables","content":"Cyclic apps run on AWS and have pre-configured AWS credentials for access to the built-in S3 storage and DynamoDB database. For this, Cyclic reserves the following environment variables: AWS_REGION AWS_ACCESS_KEY_ID AWS_SECRET_KEY AWS_SECRET_ACCESS_KEY  If you are using resources in your own AWS account and would like you add your own credentials. Consider using alternative environment variables and setting the credentials on the SDK clients directly:  const { S3Client } = require(&quot;@aws-sdk/client-s3&quot;); let client = new S3Client({ region: process.env.MY_REGION, credentials:{ accessKeyId: process.env.MY_AWS_ACCESS_KEY_ID, secretAccessKey: process.env.MY_AWS_SECRET_ACCESS_KEY } });  "},{"title":"Watch an overview here:​","type":1,"pageTitle":"Variables","url":"/concepts/env_vars#watch-an-overview-here","content":" "},{"title":"Transactions","type":0,"sectionRef":"#","url":"/concepts/transactions","content":"","keywords":""},{"title":"Transaction components​","type":1,"pageTitle":"Transactions","url":"/concepts/transactions#transaction-components","content":"Each transaction is composed of: The request sent by the caller: urlmethodquery stringheaderspayloadsource ipuser agent App initialization outputApp logging output to console or from any loggers: log payloadtype of io stdout,stderr Exceptions and runtime errorsThe response from your application: http status codeheaderspayload body "},{"title":"Using transactions for analysis and debugging​","type":1,"pageTitle":"Transactions","url":"/concepts/transactions#using-transactions-for-analysis-and-debugging","content":"In addition to the Cyclic realtime log stream, transactions are a great way to understand what is happening in your application. Transactions are available as a tab on an application view; each request to an app is presented as a request-response pair. "},{"title":"Request​","type":1,"pageTitle":"Transactions","url":"/concepts/transactions#request","content":"Given a sample request made via curl $ curl 'https://my-app.cyclic.app/?hello=world' ok  The request payload can be viewed as: "},{"title":"Response​","type":1,"pageTitle":"Transactions","url":"/concepts/transactions#response","content":"Similarly, the details of the response are viewable as: "},{"title":"Timeline​","type":1,"pageTitle":"Transactions","url":"/concepts/transactions#timeline","content":"On the back end, we had a single api handler at the root / route implemented as:  app.get('/',async (req, res) =&gt; { console.log(req.headers['user-agent']) console.log(Date.now()) console.log(req.query) console.error('this is an error') return res.send('ok') })  Cyclic presents the timeline of the logs, errors and exceptions in context of the request and response in an easy to read, syntax highlighted timeline as: "},{"title":"Limitations​","type":1,"pageTitle":"Transactions","url":"/concepts/transactions#limitations","content":"Cyclic currently allows viewing transactions from the last 15 minutesKeyword and date filters are not yet available "},{"title":"Create 'Deploy to Cyclic' button","type":0,"sectionRef":"#","url":"/how-to/create-deploy-to-cyclic-button","content":"","keywords":""},{"title":"Easy​","type":1,"pageTitle":"Create 'Deploy to Cyclic' button","url":"/how-to/create-deploy-to-cyclic-button#easy","content":"Just copy this markdown directly into your README.md file inside your repo on Github. The target https://deploy.cyclic.sh/ uses http referrer header to determine the source repo to use in targeting the app.cyclic.sh deploy path. [![Deploy to Cyclic](https://deploy.cyclic.sh/button.svg)](https://deploy.cyclic.sh/)  Renders as:  "},{"title":"HTML​","type":1,"pageTitle":"Create 'Deploy to Cyclic' button","url":"/how-to/create-deploy-to-cyclic-button#html","content":"If you would like to embed HTML directly into a site with a configured target you can set the app.cyclic.sh path yourself. Replace GH_LOGIN and GH_REPO with the values for your Github user name and repository name. For example if you wanted to create a fork and deploy button for: https://github.com/seekayel/express-hello-world The values would be: GH_LOGIN=seekayel GH_REPO=express-hello-world  &lt;a href=&quot;https://deploy.cyclic.sh/GH_LOGIN/GH_REPO&quot;&gt; &lt;img src=&quot;https://deploy.cyclic.sh/button.svg&quot; /&gt; &lt;/a&gt;  Renders as:  "},{"title":"Add a Private Repository","type":0,"sectionRef":"#","url":"/how-to/add-private-repository","content":"","keywords":""},{"title":"Add a private repo...​","type":1,"pageTitle":"Add a Private Repository","url":"/how-to/add-private-repository#add-a-private-repo","content":"Here is an example of what adding a private repository menu looks like in the dashboard.  "},{"title":"Watch a walkthrough here​","type":1,"pageTitle":"Add a Private Repository","url":"/how-to/add-private-repository#watch-a-walkthrough-here","content":" "},{"title":"Cloudflare","type":0,"sectionRef":"#","url":"/how-to/custom-domains/cloudflare","content":"","keywords":""},{"title":"Apex Domains and www​","type":1,"pageTitle":"Cloudflare","url":"/how-to/custom-domains/cloudflare#apex-domains-and-www","content":"To have requests to www.your-domain.com to be redirected to your-domain.com, configure Rules and Bulk Redirects in Cloudflare. Refer to Cloudflare documentation: Redirecting www to domain apex "},{"title":"GoDaddy","type":0,"sectionRef":"#","url":"/how-to/custom-domains/godaddy","content":"","keywords":""},{"title":"Subdomains​","type":1,"pageTitle":"GoDaddy","url":"/how-to/custom-domains/godaddy#subdomains","content":"Link a subdomain, for example api.example.com to a Cyclic app: "},{"title":"Cyclic​","type":1,"pageTitle":"GoDaddy","url":"/how-to/custom-domains/godaddy#cyclic","content":"On the app dashboard, navigate to Advanced &gt; Branding &gt; Custom DomainEnter api.example.com in the Domain Name fieldPress StartYou should see a message saying that records will be available in a few seconds. Hit Refresh if you do not see them.Cyclic will produce: "},{"title":"GoDaddy​","type":1,"pageTitle":"GoDaddy","url":"/how-to/custom-domains/godaddy#godaddy-1","content":"Navigate to DNS Management for the domainClick Add to add a record Enter the validation record Select CNAME in the Type fieldThe Name field should not include the domain portion For the Cyclic dashboard record name of _xxxxxxxxxxx.api.example.com, in GoDaddy, only enter _xxxxxxxxxxx.api Enter the routing record Select CNAME in the Type fieldThe Name field should not include the domain portion For the Cyclic dashboard record name of api.example.com, in GoDaddy, only enter api At this point, the SSL certificate is still pending, navigating to your subdomain https://api.example.com, will produce a browser error NET::ERR_CERT_COMMON_NAME_INVALID. Return to Cyclic dashboard. It will take a few minutes (up to 15 but usually less) for a certificate to be issued once the validation record has been entered. After refreshing, you should see a message that says:  https://api.example.com has been validated and is active  "},{"title":"Apex domains​","type":1,"pageTitle":"GoDaddy","url":"/how-to/custom-domains/godaddy#apex-domains","content":"Link the apex domain example.com to a Cyclic app. Apex Domains cannot be linked via CNAME The most common approach is to link the www subdomain and use forwarding in GoDaddy to set up redirect from example.com to www.example.com "},{"title":"Cyclic​","type":1,"pageTitle":"GoDaddy","url":"/how-to/custom-domains/godaddy#cyclic-1","content":"Follow the above subdomain procedure to link www.example.com to your Cyclic app.  After you have set up the records and SSL certificate was issued: Verify that you can access your app via https://wwww.example.com. "},{"title":"GoDaddy​","type":1,"pageTitle":"GoDaddy","url":"/how-to/custom-domains/godaddy#godaddy-2","content":"Navigate to DNS Management for the domain, scroll down to the Forwarding sectionClick Add Forwarding in the Domain slot Select https:// from the dropdown and enter your subdomain, www.example.com  After a few minutes, try navigating to https://example.com and you should be redirected to your Cyclic app at https://www.example.com "},{"title":"Namecheap","type":0,"sectionRef":"#","url":"/how-to/custom-domains/namecheap","content":"","keywords":""},{"title":"Generating your Cyclic DNS records​","type":1,"pageTitle":"Namecheap","url":"/how-to/custom-domains/namecheap#generating-your-cyclic-dns-records","content":"Navigate to the Advanced tab in the application you want to link your custom domain to. Enter your domain name in the &quot;Domain Name&quot; field, ex. www.mydomainiscool.comEven if your domain was purchased as an apex domain (without a www prefix) include the www prefix to make sure it points correctly.Within a minute, you can refresh the page, and your records will be available below.If you need to cancel and restart for any reason, just hit the &quot;Cancel Request&quot; button.Once Cyclic has issued a DNS record for your domain, you will see a pink highlighted box appear below. There are two sections within this box: Validation Record and Routing Record. Follow the instructions below to use this information to connect to Namecheap. "},{"title":"Connecting to Namecheap​","type":1,"pageTitle":"Namecheap","url":"/how-to/custom-domains/namecheap#connecting-to-namecheap","content":"In Namecheap, first use your Validation Record to create a CNAME record. In Namecheap, select Domain List from the sidebar and click the Manage button next to your domain.Select the Advanced DNS tab at the top of the page and hit the Add New Record Button for each record you need to add.Add a CNAME record where the Host corresponds to the &quot;Record Name/Host&quot; in your DNS record from Cyclic and the Value corresponds to the &quot;Record Value/Target&quot;. NOTE: The &quot;Record Name/Host&quot; information will tack on your domain name again if it is already included. So when you set up a CNAME record, it is crucial to ONLY insert the alphanumeric portion of the Name/Host and the wwwEx. _75d18c39a91766ee704a49763bfd3bfb.www Add a second CNAME record where the Host is www and the Value is your Cyclic generated link. This should complete the pointing of your custom URL to from Namecheap to your application on Cyclic. Bear in mind, it may take up to 48 hours for it to propagate through servers everywhere. "},{"title":"Redirects​","type":1,"pageTitle":"Namecheap","url":"/how-to/custom-domains/namecheap#redirects","content":"In Namecheap, make sure you are on the Advanced DNS page and select Add New Record for each record you need to add.We recommend the @ Host redirect for all users. Include the full URL from your Cyclic DNS record request as the Value. Failure to include https:// could cause your redirect to fail.If you would like to add additional URL redirects, follow the same pattern as above. "},{"title":"Checking your success​","type":1,"pageTitle":"Namecheap","url":"/how-to/custom-domains/namecheap#checking-your-success","content":"In Cyclic, you can check if you have completed the steps correctly. Below the pink DNS record section, there is a status box that will give you current information about your domain and SSL certificate. If you are uncertain, be sure to check here first. "},{"title":"Overview","type":0,"sectionRef":"#","url":"/how-to/custom-domains/overview","content":"","keywords":""},{"title":"Change the subdomain​","type":1,"pageTitle":"Overview","url":"/how-to/custom-domains/overview#change-the-subdomain","content":"To change the subdomain to something like myproject.cyclic.app, navigate to Environments and use the form in the Custom Subdomain panel. You will be able to select a any custom domain that hasn't already been used. "},{"title":"Add a domain you own to an app​","type":1,"pageTitle":"Overview","url":"/how-to/custom-domains/overview#add-a-domain-you-own-to-an-app","content":"You can attach a domain you own to a Cyclic app. This requires you to create two DNS records. The first record - to verify that you own the domain so that Cyclic can request the issue of an SSL certificate. The certificates are signed by AWS and are auto-renewed as long as appropriate DNS records exist. The second record, to route requests between your domain and cyclic app. CAA Record Since Cyclic delegates the issue of the SSL certificate to Amazon AWS, your DNS must allow AWS to create certs for your domain. A Certification Authority Authorization (CAA) record is used to specify which certificate authorities (CAs) are allowed to issue certificates for a domain. For the validation to succeed, your DNS configuration must either not have any CAA records specified (allows all CA's) or include a CAA record with a value amazon.com or amazonaws.com. Refer to AWS docs for more info. Request a domain on the dashboard Advanced &gt; Custom Domains panel. You will receive two DNS records to add to your registrar CNAME validation record that will look something like this: Record Name: _xxxxxxxxxxx.your-domain.com Record Value: _yyyyyyyyyyy_.abcdef.acm-validations.aws This record is used to verify domain ownership and issue an SSL certificate for myproject.your-domain.com CNAME record to point your domain at your cyclic app, something like this: Record Name: myproject.your-domain.com (the domain you requested) Record Value: some-random-words.cyclic.app This record will route traffic from your domain to your app. Once you add the records, it will take between 2 minutes to 24 hours for the domain to be live as DNS changes take time to propagate. Apex Domains A domain apex is the &quot;root&quot; level of your domain. your-domain.com is the &quot;root&quot; level, while www.your-domain.com or abc.your-domain.com are both subdomains. Your registrar may not support CNAME records at apex. Many registrars support forwarding. A common practice is to register a www subdomain and forward apex to it. "},{"title":"Set up with your domain registrar​","type":1,"pageTitle":"Overview","url":"/how-to/custom-domains/overview#set-up-with-your-domain-registrar","content":""},{"title":"Cloudflare​","type":1,"pageTitle":"Overview","url":"/how-to/custom-domains/overview#cloudflare","content":"Custom Domains ⟫ Cloudflare "},{"title":"GoDaddy​","type":1,"pageTitle":"Overview","url":"/how-to/custom-domains/overview#godaddy","content":"Custom Domains ⟫ GoDaddy "},{"title":"Additional support​","type":1,"pageTitle":"Overview","url":"/how-to/custom-domains/overview#additional-support","content":"Reach out to us for any additional support on Discord "},{"title":"Architecture","type":0,"sectionRef":"#","url":"/overview/architecture","content":"","keywords":""},{"title":"Components​","type":1,"pageTitle":"Architecture","url":"/overview/architecture#components","content":"Route53 recordsCloudFront distributionACM certificatesAPI Gateway HTTP APILog group for access loggingLambda execution environmentLog group for lambda runtimeS3 bucket for code storageBuild/deploy log storageStreaming of application logs to consoleStreaming of build/deploy logs to console "},{"title":"Design principles​","type":1,"pageTitle":"Architecture","url":"/overview/architecture#design-principles","content":"In designing and building Cyclic we must make decisions and trade offs. Here is a statement of the principles that guide our decisions, in priority order. Working vs &quot;Correct&quot;Fail quicklyFail predictablyFail visiblyRight to repair "},{"title":"Working​","type":1,"pageTitle":"Architecture","url":"/overview/architecture#working","content":"The first priority is for the system to work in the way the user expects. This may mean more complexity or difficulty for Cyclic. The elegance or simplicity of system code comes after it is working for the user. If forced to choose we will follow common usage over compliance with a technical spec. Said another way, your happiness and code elegance over our happiness and code elegance. "},{"title":"Fail quickly​","type":1,"pageTitle":"Architecture","url":"/overview/architecture#fail-quickly","content":"It is better to fail bigger and sooner than to let non-functional or partially functional code travel to the next step. Said another way, it is better to fail at the build stage letting the user know the code can't launch than to succeed and wait until the launch stage for the user to discover the code can not launch or only sorta works. If given the choice we would rather completely break sooner than be partially broken later in a process. "},{"title":"Fail predictably​","type":1,"pageTitle":"Architecture","url":"/overview/architecture#fail-predictably","content":"Failure will happen. When it does we should make it repeatable. The same inputs should lead to the same failure. Similar failures should be processed in the same way. "},{"title":"Fail visibly​","type":1,"pageTitle":"Architecture","url":"/overview/architecture#fail-visibly","content":"When errors happen we should show the error message, stack trace, or known bug. This could mean we need to email the user or tell the world on twitter. "},{"title":"Right to repair​","type":1,"pageTitle":"Architecture","url":"/overview/architecture#right-to-repair","content":"Open source is a statement about whether the software system is even available for inspection. We wish to go a step further. Right to repair means you can take a Cyclic app and poke around inside. You can &quot;eject&quot; at anytime and the app will keep running in your account. "},{"title":"Using MongoDB","type":0,"sectionRef":"#","url":"/how-to/using-mongo-db","content":"","keywords":""},{"title":"Atlas Configuration​","type":1,"pageTitle":"Using MongoDB","url":"/how-to/using-mongo-db#atlas-configuration","content":"Cyclic apps do not have static IP's for white listing with Atlas and Cyclic does not offer private networking on free tier. Setting 0.0.0.0/0 will enable access to your service cluster from all IP's and make it possible for services to authenticate via connection string. "},{"title":"Connections in a Serverless Runtime​","type":1,"pageTitle":"Using MongoDB","url":"/how-to/using-mongo-db#connections-in-a-serverless-runtime","content":"MongoDB is not an on-demand database and its connection mechanism is persistent, it can also take a moment to establish the connection for the first time. For best performance, avoid making a connection inside a route handler. Serverless environments are restarted frequently, often right when a request is made. A route handler may already be trying to serve the request before the MongoClient.connect method finishes connecting.This may result in a failure to respond from the server.  This behavior is possible in traditional long-running environments but occurs much less often because the connection event happens only when the server is restarted. Listen for requests after mongo has connected MongoDB connections should be established before a server's listen method is called. To make sure this happens every time, call the listen method in the connect callback. "},{"title":"Connection Example MongoClient​","type":1,"pageTitle":"Using MongoDB","url":"/how-to/using-mongo-db#connection-example-mongoclient","content":"MongoClient connection in a serverless runtime It is very important to make sure the MongoClient.connect is finished before allowing your app to serve requests. This example does not start listening to PORT until the DB connection is established. Requests will be held in the Cyclic runtime to make sure none are ever missed, even if the connection takes a moment.  const { MongoClient } = require('mongodb'); const express = require('express'); const app = express(); const PORT = process.env.PORT || 3000 const uri = process.env.MONGO_CONNECTION_STRING; const client = new MongoClient(uri); app.get(&quot;/items/:my_item&quot;, async (req, res) =&gt; { let my_item = req.params.my_item; let item = await client.db(&quot;my_db&quot;) .collection(&quot;my_collection&quot;) .findOne({my_item: my_item}) return res.json(item) }) client.connect(err =&gt; { if(err){ console.error(err); return false;} // connection to mongo is successful, listen for requests app.listen(PORT, () =&gt; { console.log(&quot;listening for requests&quot;); }) });  "},{"title":"Connection Example Mongoose​","type":1,"pageTitle":"Using MongoDB","url":"/how-to/using-mongo-db#connection-example-mongoose","content":"Mongoose connection in a serverless runtime It is very important to make sure that mongoose.connect is finished before allowing your app to serve requests. This example does not start listening to PORT until the DB connection is established. Requests will be held in the Cyclic runtime to make sure none are ever missed, even if the connection takes a moment. const express = require('express') const mongoose = require('mongoose') const app = express() const PORT = process.env.PORT || 3000 const connectDB = async () =&gt; { try { const conn = await mongoose.connect(process.env.MONGO_URI); console.log(`MongoDB Connected: ${conn.connection.host}`); } catch (error) { console.log(error); process.exit(1); } } //Routes go here app.all('*', (req,res) =&gt; { res.json({&quot;every thing&quot;:&quot;is awesome&quot;}) }) //Connect to the database before listening connectDB().then(() =&gt; { app.listen(PORT, () =&gt; { console.log(&quot;listening for requests&quot;); }) })  "},{"title":"Deploy","type":0,"sectionRef":"#","url":"/overview/deploy","content":"","keywords":""},{"title":"Triggering a Deployment​","type":1,"pageTitle":"Deploy","url":"/overview/deploy#triggering-a-deployment","content":"Code is deployed as soon as it's GitHub repository has been connected to Cyclic. Cyclic will use the GitHub default branch to pull the repo contents. On GitHub the default branch is usually main or master. Every git push or change to the default branch will trigger a Cyclic deployment. This includes direct pushes as well as pull request merges. "},{"title":"GitHub Environments Integration​","type":1,"pageTitle":"Deploy","url":"/overview/deploy#github-environments-integration","content":"Once deployed, apps are linked on the Github repo in the Environments section on the right hand side of the page:  For each deployment afterwards, a record will be published with a link to the deployment logs, live site, and corresponding commit hash.  "},{"title":"Build","type":0,"sectionRef":"#","url":"/overview/build","content":"","keywords":""},{"title":"Code​","type":1,"pageTitle":"Build","url":"/overview/build#code","content":"The following is a close approximation of the code we use to take your code repo and turn it into an artifact that can be run inside of AWS Lambda with the Cyclic lambda runtime. Note: we use npm version 8.13.1 throughout. npm install: Install your code's dependencies (including devDependencies)npm run build: Build your app if you have a build script defined in package.jsonnpm prune: Prune any devDependencies to minimize the size of the output zipzip: Zip all of your code and installed dependencies (for example node_modules) recursively Note: we have limits on the maximum amount of disk space used for code + dependencies while building and on the final bundle size. See limits page for more details. "},{"title":"Customize the build process​","type":1,"pageTitle":"Build","url":"/overview/build#customize-the-build-process","content":"NPM executes several lifecycle scripts as part of the npm install and npm run build. According to the documentation these are run in the following order: npm install preinstallinstallpostinstallprepublishprepreparepreparepostprepare npm run build prebuildbuildpostbuild If you have particular needs try putting it into the appropriate lifecycle script. If you have needs beyond what these lifecycle scripts can provide or they don't solve for your use case send us an email: hello@cyclic.sh or join us on Discord "},{"title":"Advanced Build Options​","type":1,"pageTitle":"Build","url":"/overview/build#advanced-build-options","content":"By default, the build process and the above lifecycle scripts: run at the root of the repo everything at the root of the repo is bundled except files specified in .npmignore At runtime npm run start is used to execute the application It is possible to customize this process with Advanced Build Options: at the time of first deployment, in the Advanced dropdown in Environments tab &gt; Build Options of an app's dashboard Root Path​ The root path specifies which directory Cyclic will run build scripts. For example for a repository structured as: ├──/frontend | ├── ... | └── package.json ├──/backend | └── ... └──package.json  To have cyclic run npm run build in the frontend directory, configure &quot;Root Path&quot; as /frontend. Output Path​ The contents of the Output Path are bundled for deployment. For example if at the end of the above build, a build directory is generated inside /frontend: ├──/frontend | ├── build | | ├── index.html | | └── package.json | ├── ... | └── package.json ├──/backend | └── ... └──package.json  To make sure that the build output are the only files to be bundled, specify /frontend/build as the Output Path. npm run start Unless the output is a static site, the output directory should still contain a package.json with a valid start script for run time. Read more about the launch procedure. Static Site​ Check this toggle if the contents of the output directory are only static files and do not contain a server instance. This applies to build outputs of static site framework builds such as React, Vue, Angular, etc. This video will give you an example of how to deploy a static site without a backend on Cyclic:  Runtime​ Newly deployed Cyclic apps will use Node.js v18.12.1 by default. If you are using a framework or library that requires an older version of Node.js to function properly, you may adjust it here.  "},{"title":"Launch","type":0,"sectionRef":"#","url":"/overview/launch","content":"","keywords":""},{"title":"Start​","type":1,"pageTitle":"Launch","url":"/overview/launch#start","content":"Cyclic runs nodejs apps and follows general conventions for running them. In order to identify how to start, a package.json file must exist in the root of the repo.  It is expected that the start command launches an application that listens to http requests on a TCP port. The convention for nodejs applications has been port 3000 and best practices suggest exposing the port configuration as an environment variable as: const port = process.env.PORT || 3000  Cyclic supports but does not require setting a port via the environment variables. Automatic Port Discovery The port that the application is listening to is identified automatically. Port 9001 is reserved for the runtime, other than that any port can be used and will be automatically selected. "},{"title":"Fallbacks​","type":1,"pageTitle":"Launch","url":"/overview/launch#fallbacks","content":"npm start is the default behavior, the following is the full sequence of fallbacks to identify entry point: npm start will run the start script defined in package.json: &quot;scripts&quot;: { &quot;start&quot;: &quot;node foo.js&quot; } If a scripts property does not exist or a start script is not defined: npm's default behavior is to run node server.js If server.js does not exist: Cyclic will fall back to running node . which expects the entry point to be defined in the package.json under the main property If the main property does not exist in the the package.json, node's default behavior is to look for an index.js file as the main entry pointIf none of these have been satisfied, the runtime will produce a 500 error on requests "},{"title":"Failures​","type":1,"pageTitle":"Launch","url":"/overview/launch#failures","content":"If you code fails to initialize then you may get an error at your URL endpoint that says: Unable to proxy. This is due to your app either not listening on the correct port or failing to start properly from the call to npm start. "},{"title":"Limits","type":0,"sectionRef":"#","url":"/overview/limits","content":"","keywords":""},{"title":"Hard limits​","type":1,"pageTitle":"Limits","url":"/overview/limits#hard-limits","content":"Runtime Node.js 18.x, 16.x or 14.x.30s Maximum request time6MB Maximum HTTP request payload size6MB Maximum HTTP response payload sizeNo streaming of requests or responses240 MB final code bundle size per app512MB of ephemeral disk space mounted at /tmp the data will persist between invokes but there is no guarantee that any further invocations will use the same instance and thus can not be relied on to store persistent data. 5 TB single file size in S3 storage "},{"title":"Soft limits​","type":1,"pageTitle":"Limits","url":"/overview/limits#soft-limits","content":"5 API requests per second steady state (for free tier)10 API requests per second in a burst (for free tier)10 GB code and dependencies file size while building1 GB of S3 storage (for free tier)10 GB of S3 transfer out to internet (for free tier)1 GB of DynamoDB storage (for free tier) "},{"title":"AWS Regions​","type":1,"pageTitle":"Limits","url":"/overview/limits#aws-regions","content":"Cyclic apps are launched in the following regions: af-south-1ap-east-1ap-northeast-1ap-northeast-2ap-south-1ap-southeast-1ap-southeast-2ca-central-1eu-central-1eu-north-1eu-south-1eu-west-1eu-west-2eu-west-3me-south-1sa-east-1us-east-1us-east-2us-west-1us-west-2 "},{"title":"TLDR","type":0,"sectionRef":"#","url":"/quick-start","content":"","keywords":""},{"title":"Quick start example​","type":1,"pageTitle":"TLDR","url":"/quick-start#quick-start-example","content":"Launch a pre-baked expressjs starter:  "},{"title":"Product tour​","type":1,"pageTitle":"TLDR","url":"/quick-start#product-tour","content":" "},{"title":"Launching your own app​","type":1,"pageTitle":"TLDR","url":"/quick-start#launching-your-own-app","content":"Go to the Link Your Own tab on the deployment page. This will let you chose a repo from one of your public GitHub repos.  Here is what you need to know: Cyclic supports nodejs apps that live in github repos A package.json must exist at the root of the repo On every deployment Cyclic will run npm install for production and will prune dev dependencies Cyclic will also run npm run build if a build script has been defined in the package.json The package.json should have a scripts property with a start command Cyclic will run your apps by calling npm run start The start command must start a server on a port Cyclic will discover the port automatically or you can configure it in environment variables All apps are serverless New deployments will be triggered automatically on code changes to the default branch of the repo "},{"title":"Next steps?​","type":1,"pageTitle":"TLDR","url":"/quick-start#next-steps","content":"You can try one of our other starters listed on the starters page "},{"title":"On-Demand","type":0,"sectionRef":"#","url":"/serverless/on-demand","content":"","keywords":""},{"title":"Limitations and Solutions​","type":1,"pageTitle":"On-Demand","url":"/serverless/on-demand#limitations-and-solutions","content":"This can limit some traditional server use cases: "},{"title":"Sockets​","type":1,"pageTitle":"On-Demand","url":"/serverless/on-demand#sockets","content":"Socket connectivity is not available because it requires the server to continuously be connected to a potentially idle client. Read more Workaround Some popular socket connection libraries such as SocketIO have automatic fallback mechanisms to revert to polling for this scenario. Polling works for many use cases that do not require instantaneous real-time push from server. Keep in mind that polling uses up a lot of requests and choose an appropriate polling rate for your use-case that is not excessive. "},{"title":"Background Processes​","type":1,"pageTitle":"On-Demand","url":"/serverless/on-demand#background-processes","content":"Since the environments are driven on and off by network requests. It is impossible to keep a background process running longer than the time it takes to process a single request (max 30 seconds). If the background process can be short-lived, you may be able to manage starting alongside your Node.js app. Short-Lived Background Processes Even though it is not possible to run a background process longer than it takes to serve a request, a short-lived process can be started alongside your Node.js app by scripting its execution as part of the start script in package.json. "},{"title":"Cron Tasks​","type":1,"pageTitle":"On-Demand","url":"/serverless/on-demand#cron-tasks","content":"Cron tasks are technically long running processes and cannot be run in the same way that they do in a unix environment. You can still build the behavior you need by specifying cron tasks in the Cyclic dashboard. Cron Tasks The Cyclic dashboard allows you can configure scheduled requests to specific api routes to run up to once an hour (with one second resolution) or trigger at a specific time (one second resolution). "},{"title":"Async/Await​","type":1,"pageTitle":"On-Demand","url":"/serverless/on-demand#asyncawait","content":"Runtimes are suspended immediately after each response is sent. This means all promises must be resolved before a response is returned. In the following snippet, the db.write method takes some time. The database will probably be written to on local or in a persistent environment, but this writing actually happens after the response ok has already been sent.  // BAD CODE - Example of not using await before returning router.post('/some_route', requiresAuth(), async (req, res) =&gt; { db.write(req.body) res.send('ok') })  A serverless environment is suspended as soon as ok is sent, and the write may fail without producing an error. To avoid these issues, make sure any promises are resolved before sending responses:  router.post('/some_route', requiresAuth(), async (req, res) =&gt; { await db.write(req.body) return res.send('ok') })  "},{"title":"Starters","type":0,"sectionRef":"#","url":"/overview/starters","content":"","keywords":""},{"title":"APIs​","type":1,"pageTitle":"Starters","url":"/overview/starters#apis","content":""},{"title":"Vanilla Nodejs​","type":1,"pageTitle":"Starters","url":"/overview/starters#vanilla-nodejs","content":"The smallest possible node backend with no dependencies.Source: https://github.com/cyclic-software/starter-micro-api  "},{"title":"Express API​","type":1,"pageTitle":"Starters","url":"/overview/starters#express-api","content":"Minimal Express backend with just a few lines of codehttps://github.com/cyclic-software/starter-express-api  "},{"title":"REST API​","type":1,"pageTitle":"Starters","url":"/overview/starters#rest-api","content":"Fully functional REST API Create Read Update Delete, ListBacked by integrated DynamoDB https://github.com/cyclic-software/starter-rest-api  "},{"title":"Full Stack​","type":1,"pageTitle":"Starters","url":"/overview/starters#full-stack","content":""},{"title":"HTML Full Stack​","type":1,"pageTitle":"Starters","url":"/overview/starters#html-full-stack","content":"An express app serving a static html page with some cool cssSource: https://github.com/cyclic-software/express-hello-world  "},{"title":"NextJS Full Stack​","type":1,"pageTitle":"Starters","url":"/overview/starters#nextjs-full-stack","content":"A NextJS static site with a small Express API backendSource: https://github.com/cyclic-software/starter-nextjs  "},{"title":"Frontends​","type":1,"pageTitle":"Starters","url":"/overview/starters#frontends","content":""},{"title":"React Frontend​","type":1,"pageTitle":"Starters","url":"/overview/starters#react-frontend","content":"Vanilla React App. Created with npx create-react-app template.Source: https://github.com/cyclic-software/starter-react-app  "},{"title":"Vue Frontend​","type":1,"pageTitle":"Starters","url":"/overview/starters#vue-frontend","content":"Vanilla Vue App. Created with npx @vue/cli create starter-vueSource: https://github.com/cyclic-software/starter-vue  "},{"title":"Svelte Frontend​","type":1,"pageTitle":"Starters","url":"/overview/starters#svelte-frontend","content":"Vanilla Svelte App. Created with npx degit sveltejs/templateSource: https://github.com/cyclic-software/starter-svelte  "},{"title":"Bots​","type":1,"pageTitle":"Starters","url":"/overview/starters#bots","content":""},{"title":"Discord Bot​","type":1,"pageTitle":"Starters","url":"/overview/starters#discord-bot","content":"Discord Bot starter DM's and Slash commandsSource: https://github.com/cyclic-software/starter-discord-bot  "},{"title":"Telegram Bot​","type":1,"pageTitle":"Starters","url":"/overview/starters#telegram-bot","content":"Telegram inline queries, commands and interactive inline keyboardsSource: https://github.com/cyclic-software/starter-telegram-bot  "},{"title":"Slack Bot​","type":1,"pageTitle":"Starters","url":"/overview/starters#slack-bot","content":"Slack Bot starter built on BoltjsSource: https://github.com/cyclic-software/starter-slack-boltjs  "},{"title":"Data​","type":1,"pageTitle":"Starters","url":"/overview/starters#data","content":""},{"title":"S3 Storage​","type":1,"pageTitle":"Starters","url":"/overview/starters#s3-storage","content":"Use Cyclic Storage backed by AWS S3Source: https://github.com/cyclic-software/starter-s3-storage  "},{"title":"DynamoDB Example​","type":1,"pageTitle":"Starters","url":"/overview/starters#dynamodb-example","content":"Fully functional REST API Create Read Update Delete, ListBacked by integrated DynamoDB https://github.com/cyclic-software/starter-rest-api  "},{"title":"Overview","type":0,"sectionRef":"#","url":"/serverless/overview","content":"","keywords":""},{"title":"Compute is provisioned on-demand​","type":1,"pageTitle":"Overview","url":"/serverless/overview#compute-is-provisioned-on-demand","content":"runtime is started when a request is receivedruntime suspended after a response is sentmultiple runtimes can be active simultaneously On-Demand Runtimes - Read More "},{"title":"Compute is stateless​","type":1,"pageTitle":"Overview","url":"/serverless/overview#compute-is-stateless","content":"runtimes do not retain memory after they are shut downwrite access is only available to the /tmp directorysimultaneously active runtimes do not share memory or /tmp disk Stateless Runtimes - Read More "},{"title":"Common Error Codes","type":0,"sectionRef":"#","url":"/troubleshooting/error-codes","content":"","keywords":""},{"title":"Build Options Errors​","type":1,"pageTitle":"Common Error Codes","url":"/troubleshooting/error-codes#build-options-errors","content":"ENOENTNo such file or directory - Specify build folder See Advanced Build Options Unable to load legacy provider/digital envelope routines unsupported - Revert to older version of Node See Advanced Build Options Cannot find Data Entry Point - Specify which directory Cyclic should look in for package.json See Main Entry Point Does Not Exist ERROR: The total size of the post-build project code and production dependencies cannot exceed 240MB - Remove or move dependencies See Size Limits "},{"title":"Timeout Error​","type":1,"pageTitle":"Common Error Codes","url":"/troubleshooting/error-codes#timeout-error","content":"Timeout error - We have a 30 second hard limit on requests. See Background Processes "},{"title":"Database Errors​","type":1,"pageTitle":"Common Error Codes","url":"/troubleshooting/error-codes#database-errors","content":"MongoParseError - Usually an issue with MongoDB or Mongoose configuration. See Using MongoDB 500 error when trying to load page - Start by whitelisting all IPs (0.0.0.0/0) in your Atlas Cluster See Using MongoDB EROFSRead-only file system with '/var/task/tmp/tmp' or &quot;unable to open for write unix&quot; - This is the read-only file system error. One solution is the use the S3fs module provided by Cyclic. See File System "},{"title":"Other Errors​","type":1,"pageTitle":"Common Error Codes","url":"/troubleshooting/error-codes#other-errors","content":"Cannot find module &quot; &quot; - If Cyclic is unable to find or run a specific module, it may not be available to Cyclic because of errors in the code or because it is not supported. Ex: CORS - Make sure CORS is installed and required if you are receiving this message in regards to CORS.EX: Websockets - If you see &quot;Cannot Find Modules 'ws'&quot;, it is in reference to WebSockets. Read more about Cyclic and Websockets here. npm ERR! gyp ERR! - Node-gyp requires Python. Because Python is not currently supported on Cyclic, you will not be able to use this package on Cyclic, resulting in this error. Even if you are not actively using Python in your code, you will encounter this error.ERROR:Failed to run &quot;npm run start&quot; - Make sure your package.json is in the build folder.&quot;Runs on local, but doesn't run on Cyclic&quot; - Not an error code, persay, but a frequent concern. Here's how to troubleshoot: Check package.json has all required dependencesCheck that your start script is defined and runs Check your environment varibales are set and match your expectations "},{"title":"Stateless","type":0,"sectionRef":"#","url":"/serverless/stateless","content":"","keywords":""},{"title":"Limitations and Solutions​","type":1,"pageTitle":"Stateless","url":"/serverless/stateless#limitations-and-solutions","content":"Special precautions should be used for the following use-cases: "},{"title":"In-Memory Sessions​","type":1,"pageTitle":"Stateless","url":"/serverless/stateless#in-memory-sessions","content":"Basic session implementations are usually built with the assumption that the server process is never interrupted. This can be an issue even in stateful environments, where a server re-start will cause sessions to be lost. With serverless runtimes, re-starts happen quickly (~0.2s) and frequently. Database backed sessions Best practices for stateful environments will dictate that sessions should be backed up to a database. With serverless, storing sessions in a database is a must. There are many libraries and session extensions that enable this for a variety of databases. Check out our npm package that will let you use apps' built-in AWS DynamoDB database for session storage. &gt;&gt; @cyclic.sh/session-store "},{"title":"File Upload​","type":1,"pageTitle":"Stateless","url":"/serverless/stateless#file-upload","content":"Serverless apps run on read-only file systems. This means it is impossible to persistently store files to disk. AWS S3 and Uploading/Downloading Files Cyclic exposes many features of AWS S3 directly to your apps. To handle uploads directly to the object store, S3 can be used to generate pre-signed GET, PUT and POST urls than can be used by a client to upload and download files over the 6MB api size limitation. Read more on presigned URLs Processing and Uploading​ The /tmp directory can be written to. But it should only be used for intermediary processing. Either upload the result to an object store or download to the client. An example use case for /tmp may be to create thumbnail images, store them in /tmp, and then upload them to S3. "},{"title":"db.json​","type":1,"pageTitle":"Stateless","url":"/serverless/stateless#dbjson","content":"A popular pattern with many tutorials is to simulate a database by reading and writing records to and from a db.json file. In traditional server environments, this pattern may work for some very low volume of read's and write's, it will very quickly become vulnerable to race conditions and should be avoided even in those environments. While it is possible to write to the /tmp directory in a stateless runtime, the /tmp directory is not shared between multiple instances of the application and is lost after each shutdown. This makes the same issues that arise in a stateful environment immediately apparent. danger Do not use a json file as your database. Cyclic has a database you can use for free. "},{"title":"Main entry point does not exist","type":0,"sectionRef":"#","url":"/troubleshooting/main-entry-point-does-not-exist","content":"","keywords":""},{"title":"Error message​","type":1,"pageTitle":"Main entry point does not exist","url":"/troubleshooting/main-entry-point-does-not-exist#error-message","content":"ERROR: The main entry point defined in package.json 'index.js' does not exist. https://docs.npmjs.com/cli/v8/configuring-npm/package-json#main &quot;main&quot;: &quot;index.js&quot; To fix do the following: - update the entry in package.json that points to the correct file: &quot;main&quot;:&quot;./some_folder/some_file.js&quot;,  "},{"title":"Solution​","type":1,"pageTitle":"Main entry point does not exist","url":"/troubleshooting/main-entry-point-does-not-exist#solution","content":"Cyclic launches your code by running node .. By default this will look for a main entry in your package.json. If that entry does not exist it will then default to server.js. Either you can define a main entry that points to your entry point - for example: { &quot;main&quot;: &quot;src/index.js&quot;, ... }  Or, you can ensure the entry point to your Express application is a server.js file in the root directory. "},{"title":"Why does this happen?​","type":1,"pageTitle":"Main entry point does not exist","url":"/troubleshooting/main-entry-point-does-not-exist#why-does-this-happen","content":"By default when you run npm init it creates a main entry in package.json which points to index.js. Most frameworks init their entry points in files other than index.js in the root directory. Hence the mismatch in default behavior. "},{"title":"Size limits","type":0,"sectionRef":"#","url":"/troubleshooting/no-space-left-on-device","content":"","keywords":""},{"title":"Bundle limit​","type":1,"pageTitle":"Size limits","url":"/troubleshooting/no-space-left-on-device#bundle-limit","content":"The size of the packaged code that is deployed is limited to 240 MB. By default any generated files and the entire repo contents are packaged. Several SPA frameworks (including React) by default include build time tools in standard generated dependencies. If you move these to devDependencies you will most likely resolve any space issues. "},{"title":"Error message​","type":1,"pageTitle":"Size limits","url":"/troubleshooting/no-space-left-on-device#error-message","content":"2021-12-06 10:49:49: [CYCLIC] ERROR: The total size of the post-build project code and production dependencies cannot exceed 240MB. The total size of your build is ${mb} MB  If you get an error in the deploy log that says production dependencies cannot exceed 240MB, here is how to fix. "},{"title":"Solution​","type":1,"pageTitle":"Size limits","url":"/troubleshooting/no-space-left-on-device#solution","content":"Currently the code size is limited to 240MB. Fortunately, most projects are can to be optimized by appropriately organizing dependencies and excluding unnecessary files from the build. remove any unused dependenciesmove any dev dependencies to devDependenciesadd file patterns to an .npmignore file to exclude them from the build .npmignore uses the same syntax as .gitignore Read more about ignoring path patterns "},{"title":"Build environment limit​","type":1,"pageTitle":"Size limits","url":"/troubleshooting/no-space-left-on-device#build-environment-limit","content":"The build environment has 10 GB disk and 10 GB RAM available for temporary use to run installation and build npm scripts defined in the repos package.json. "},{"title":"Error message​","type":1,"pageTitle":"Size limits","url":"/troubleshooting/no-space-left-on-device#error-message-1","content":"If your space requirements exceed these amounts, while running the install or step you will see a No space left on device error. fatal: cannot create directory at 'some_large_file.txt': No space left on device 2021-12-06 10:49:49: [CYCLIC] Build Failed Push a new commit to start another.  "},{"title":"Solution​","type":1,"pageTitle":"Size limits","url":"/troubleshooting/no-space-left-on-device#solution-1","content":"The only resolution at this time is to trim your dependencies or devDependencies. "},{"title":"Nodemon","type":0,"sectionRef":"#","url":"/troubleshooting/nodemon","content":"","keywords":""},{"title":"Error message​","type":1,"pageTitle":"Nodemon","url":"/troubleshooting/nodemon#error-message","content":"After first deploying your app, you visit the url and see: { &quot;message&quot;: &quot;Internal Server Error&quot; }  You then investigate further by going to the Logs or Transactions tab of your app and see something like: 2021-12-20 08:37:31: sh: nodemon: command not found 2021-12-20 08:37:31: internal/modules/cjs/loader.js:905 [...]  or something like: 2021-12-20 08:45:53: internal/modules/cjs/loader.js:905 throw err; ^ Error: Cannot find module '../lib/cli' Require stack: - /var/task/node_modules/.bin/nodemon ...  "},{"title":"Solution​","type":1,"pageTitle":"Nodemon","url":"/troubleshooting/nodemon#solution","content":"This is happening because your package.json is using nodemon in its start script definition: ... &quot;scripts&quot;: { &quot;test&quot;: &quot;mocha tests/unit/&quot;, &quot;start&quot;: &quot;nodemon server.js&quot; } ...  Nodemon is an excellent tool for local development of node applications. On your local, nodemon watches for file changes at the path it is monitoring and restarts the local server. In production mode, both for serverless or not - restarting the server on file changes is usually not a desired behavior. The above package.json should be changed to: ... &quot;scripts&quot;: { &quot;test&quot;: &quot;mocha tests/unit/&quot;, &quot;dev&quot;: &quot;nodemon server.js&quot; &quot;start&quot;: &quot;node server.js&quot; } ...  While the &quot;start&quot; script may differ for various node frameworks, it should be defined for the purpose of starting the application in production mode with the appropriate flags and parameters. By convention the &quot;dev&quot; script is used to start the application in development mode primarily for running on local installations. "},{"title":"Watch an overview here:​","type":1,"pageTitle":"Nodemon","url":"/troubleshooting/nodemon#watch-an-overview-here","content":" "},{"title":"Websockets","type":0,"sectionRef":"#","url":"/troubleshooting/websockets","content":"","keywords":""},{"title":"Why?​","type":1,"pageTitle":"Websockets","url":"/troubleshooting/websockets#why","content":"Serverless functions are active on-demand for just long enough to process a single event. After the processing task is finished, often just a few milliseconds, the runtime is suspended until it is again invoked by another event. The on-demand short lifecycle enables applications to have massive scalability with almost no idle cost. Websockets require a persistent bi-directional link. In most websockets implementations, for an idle connection, a compute instance must be reserved for the duration of the connection regardless of whether a message is available for processing or not. At the same time, if a high traffic volume is possible - potentially many compute instances should be reserved in anticipation. This creates the need for further complexity in capacity planning and managing tasks to facilitate the scaling up and down of the sizing and number of compute instances. "},{"title":"Possible Alternatives​","type":1,"pageTitle":"Websockets","url":"/troubleshooting/websockets#possible-alternatives","content":"There are several realtime API services that you might use to create a similar effect to websockets. As a starting point, the ones on this list are creditable and well-supported: AblyPusherPubNub "},{"title":"Getting Started with a RESTful API","type":0,"sectionRef":"#","url":"/tutorials/rest-api-and-dynamodb/part-1","content":"","keywords":""},{"title":"A quick refresher on server-side programming​","type":1,"pageTitle":"Getting Started with a RESTful API","url":"/tutorials/rest-api-and-dynamodb/part-1#a-quick-refresher-on-server-side-programming","content":""},{"title":"How servers power the Internet​","type":1,"pageTitle":"Getting Started with a RESTful API","url":"/tutorials/rest-api-and-dynamodb/part-1#how-servers-power-the-internet","content":" Before we delve deeper into RESTful APIs, let's start from its origins and make sure that we all agree on what a web server is. From a hardware point-of-view, a web server is a physical computer that stores and serves data over the Internet, and that includes everything from HTML documents, CSS stylesheets, images and video files. Furthermore, every web server must run an HTTP server. That's a piece of software that takes-in URLs and processes them to deliver content back to the end-users, while using the HTTP protocol to facilitate the sharing of information over the Internet. tip And if the URL is wrong, the server will generate a response with the infamous 404 code instead. "},{"title":"Servers communicate with browsers using the HTTP protocol​","type":1,"pageTitle":"Getting Started with a RESTful API","url":"/tutorials/rest-api-and-dynamodb/part-1#servers-communicate-with-browsers-using-the-http-protocol","content":"When you search for a product, view details on it or even buy it, an HTTP request is sent to a web server. HTTP is a web standard that allows any server to know what to expect when it receives an HTTP request: a URL linking to the resource,request parameters defined in the query string, (like google.com/?q=my%20search)a method defining the desired action, (whether to get, create or delete that resource)JSON data encoded in the request body or in associated cookies. HTTP servers proceed by processing the request, then sending an HTTP response back to the sender. The response includes a status line indicating the result of that operation. Success for example, is represented with the HTTP/1.1 200 OK code. Unavailable resources would instead respond with the HTTP/1.1 404 NOT FOUND code. And just like any other resource, static websites are just HTML files hosted on web servers. (with a hint of CSS files, JS files and other media)  Sounds good, we just learnt that servers are the building-blocks of the Internet, and that they're responsible for storing static resources and serving them back to the users of the Internet. But what about websites that are always changing? Think Walmart, for example. It's an online store that's constantly changing: adding new products,tracking how many articles of an item are in-stock,and storing private user-specific data, such as shopping carts. These kinds of websites, which may even be categorized as full-fledged applications, are usually using an API (Application Programming Interface) behind the scenes. Instead of delivering whole HTML files, APIs only return useful information (usually in JSON format) that may be used to build a website. For instance, the Walmart API may have one URL for retrieving the list of items in display: [ { &quot;name&quot;: &quot;Oranges&quot;, &quot;inStock&quot;: 8, &quot;description&quot;: &quot;...&quot; }, { &quot;name&quot;: &quot;Table&quot;, &quot;inStock&quot;: 0, &quot;description&quot;: &quot;...&quot; } ]  It may fetch this data from a database that's maintained by an entirely different department in Walmart. The sender of the HTTP request, then, can solely focus on using this information to build a website and show it to the end-user. Web servers are critical in the creation of APIs that rely on dynamic data: they efficiently deliver tailored-made recommendations to your users,they power dynamic search results and e-commerce products inventory,and they give control access to private user information. With this kind of separation, our website can use JavaScript to fetch data from our API and then use a client-side framework such as React to build the end-user interface. Furthermore, server-side code can be written in a variety of programming languages, including but not limited to PHP, Python, Ruby, and C#. But why stray away from the same language that we already use in client-side programming? With Node, we're able to write our back-end code in JavaScript, giving us full access to the server operating system. (storage, networking, scheduling, and more.) It runs directly in the server operating system, while adding new modules including HTTP and file-system libraries. When both the front-end and back-end sides of an application are written in the same language, developers experience less of &quot;context shift&quot;, making it ideal for large-scale projects. // Example of a web server written in Node const http = require('http'); const fs = require('fs'); const path = require('path'); http .createServer((request, response) =&gt; { console.log(`request ${request.url}`); let filePath = `.${request.url}`; if (filePath === './') { filePath = './index.html'; } const extname = String(path.extname(filePath)).toLowerCase(); const mimeTypes = { '.html': 'text/html', '.js': 'text/javascript', '.css': 'text/css' }; const contentType = mimeTypes[extname] ?? 'application/octet-stream'; fs.readFile(filePath, (error, content) =&gt; { if (error) { if (error.code === 'ENOENT') { fs.readFile('./404.html', (error, content) =&gt; { response.writeHead(404, { 'Content-Type': 'text/html' }); response.end(content, 'utf-8'); }); } else { // ... and much more code!  But writing your own server in Node itself isn't very practical. Many tasks such as handling different HTTP verbs (like GET and POST) for the same route aren't supported in Node by default, meaning that you'd have to reinvent the wheel by making your own web framework! // Example of web server written with Express const express = require(&quot;express&quot;); const app = express(); const port = 3000; app.get(&quot;/&quot;, (req, res) =&gt; { res.send(&quot;Hello World!&quot;); }); app.listen(port, () =&gt; { console.log(`Example app listening on port ${port}`); });  Thankfully, Node comes with its own package manager, giving us access to a plethora of community-made modules. One of those modules is Express, the most popular Node web framework. It comes with a variety of features out of the box: Handling requests for the same URL with different HTTP verbs,Parsing JSON data straight from HTTP requests,Reading query data straight from HTTP requests,Running &quot;middleware&quot; for any routes before handling the requests. (Useful for authentication) Express also comes with its own bundle of community-made middleware to handle all kinds of necessities such as parsing cookies and security headers. We'll be using Express in the remainder of this tutorial. "},{"title":"Let's understand RESTful APIs​","type":1,"pageTitle":"Getting Started with a RESTful API","url":"/tutorials/rest-api-and-dynamodb/part-1#lets-understand-restful-apis","content":" Server-side programmers have the ability to build their APIs however they want. That's the freedom that Node and Express give you: you get to name your own routes,you get to handle different HTTP verbs in any way you want,and you even get to format the responses in whichever way you desire. But with all this freedom comes a problem: we want all APIs to be unified under one standard; one way of formatting routes; one way of handling HTTP verbs; and one way of sending responses. That's where REST comes in; it stands for &quot;Representational State Transfer&quot; and defines a universal standard for building APIs. REST recommends building your API around database(s), where each URL links in one way or another to one or more resources in that database. REST calls for the use of the following HTTP verbs: GET is for fetching the resource.POST is for creating the resource.DELETE is for deleting the resource.PUT is for updating the whole resource.PATCH is for updating parts of the resource. caution It's important that GET (also known as a &quot;Safe method&quot;) requests do not change anything about the database. RESTful APIs handle routes in an idempotent manner, meaning that making the same request multiple times yields the same result. They must also be stateless, meaning that all necessary data to handle the request is contained within the request itself and not remembered from a previous request. This makes RESTful APIs much more scalable than their counterparts. Developers use cURL to debug their APIs, a Linux command that comes pre-installed on most modern distributions. Let's demonstrate it on the RESTful API that we'll be making in this tutorial. For starters, it's incredibly easy to make GET requests: curl https://bikes.cyclic.app/bikes/all   It's also more convenient to use cURL with another command-line utility called jq. After installing it on your own machine, run the following: curl https://bikes.cyclic.app/bikes/all | jq .   Then, we can add Query Strings to our request to access the API's search feature, which we'll soon build ourselves: curl &quot;https://bikes.cyclic.app/bikes/search/by-title/?query=Mountain&quot; | jq .   We can also make make POST requests to our API using cURL; let's create a new bike item. // request.json { &quot;productType&quot;: &quot;Mountain Bicycle&quot;, &quot;createdAt&quot;: &quot;Sat Jun 27 2076 09:24:47 GMT+0100 (GMT+02:00)&quot;, &quot;vendor&quot;: &quot;Cyclic&quot;, &quot;totalInventory&quot;: 5, &quot;availableForSale&quot;: false, &quot;priceRange&quot;: { &quot;minPrice&quot;: { &quot;currencyCode&quot;: &quot;USD&quot;, &quot;amount&quot;: 2043 }, &quot;maxPrice&quot;: { &quot;currencyCode&quot;: &quot;USD&quot;, &quot;amount&quot;: 2303 } }, &quot;description&quot;: &quot;Ride the greatest line of your life with the all new and updated Countach from Cyclic. Make no compromises between speed, handling and durability.&quot;, &quot;title&quot;: &quot;Mountain Bicycle Countach&quot; }  curl -H &quot;Content-Type: application/json&quot; https://bikes.cyclic.app/bikes/ -d @request.json   Uh-oh, we just got an HTTP UNAUTHORIZED error. After looking-up the meaning of HTTP status codes, we see that &quot;UNAUTHORIZED&quot; means that we do not have access to that particular route, yet. (and of course, we'll be building this authentication system ourselves in this article) After looking up our API's documentation on GitHub, we learn that a &quot;Bearer token&quot; is required to make POST requests. We also learn that in order to create a Bearer token, we must send a POST request to the following route. This one, however, does not require authentication. curl -X POST https://bikes.cyclic.app/api/user | jq .token -r   Let's try making our request again. Bearer tokens go into the &quot;Authorization&quot; header of the HTTP request and must be formatted in this manner: Bearer &lt;TOKEN&gt;. export TOKEN=... curl -H &quot;Content-Type: application/json&quot; -H &quot;Authorization: Bearer $TOKEN&quot; https://bikes.cyclic.app/bikes/ -d @request.json | jq .   As you can see, cURL is pretty powerful and we'll be using it time and again throughout this guide. "},{"title":"Using AWS DynamoDB to store & retrieve data​","type":1,"pageTitle":"Getting Started with a RESTful API","url":"/tutorials/rest-api-and-dynamodb/part-1#using-aws-dynamodb-to-store--retrieve-data","content":" As we just learned, RESTful APIs are built around databases. But what really is a database? Well, a database is a set of inter-connected collections of information. For example, a database may contain a collection of users and a collection of products. Users and products may be connected through shopping carts. (Product A exists in User B's shopping cart) Some databases require every collection to have a fixed-set of data-points. For example, a user might have a name, a phone number and an email address. That would be the constraint in a schema-enabled database. Collections might also be seen as tables in this case, with a fixed number of columns that have their own data-type. (such as text, integer, booleans, and more) On the other hand, schema-less databases have no such limitation. Each item in a collection is a JSON document, and it can have any structure desired. Such databases are also referred to as noSQL databases, while their counterparts are known as SQL databases. A user, for example, might have the following entry in a noSQL database: { &quot;name&quot;: &quot;John Doe&quot;, &quot;isActive&quot;: true, &quot;email&quot;: &quot;example@domain.tld&quot; }  SQL is a language used for processing schema-enabled databases. It allows for the efficient searching and processing of information even on the biggest databases out there. But with DynamoDB, a noSQL database engineered by Amazon's Web Services (AWS), you still get to enjoy almost the whole power of SQL whilst feeling the freedom that comes with schema-less databases. It's called PartiQL. We're building a bikes shop API, so our database should contain a collection of bikes. It's a mix of Strings, Numbers and even whole Objects. Keep reading to see how we'll be shaping our API around this database. "},{"title":"Getting started with a RESTful API​","type":1,"pageTitle":"Getting Started with a RESTful API","url":"/tutorials/rest-api-and-dynamodb/part-1#getting-started-with-a-restful-api-1","content":"Requirements: Node (14+)NPM (8+)cURL (7+) and it won't hurt to take a quick refresher on ES6 JavaScript programming. We just spent a lot of time trying to understand REST in theory, but nothing can beat learning by practice. So let's create our own API. Our theme is a bikes shop, so that's how we'll be modelling our RESTful routes. Cyclic offers its users with a variety of starter templates, and REST APIs are included, of course. So let's begin our exciting journey by visiting Cyclic's starters and deploying the REST API.  This will fork the aforementioned starter repository to your own Github account (that you used to sign in with Cyclic). Proceed by cloning the repository to your local machine using the git clone command, which you can copy from Github. Make sure that git is installed on your machine, of course. We'll be using ECMA6 import and export statement in this project, so open package.json and set the project's type to &quot;module&quot;. // package.json { &quot;type&quot;: &quot;module&quot; }  Then, we'll replace all instances of require with import: import express from &quot;express&quot;; import db from &quot;cyclic-dynamodb&quot;;  Link to full code. And since we're building our API around our a DynamoDB database, we need to make sure that we have read and write access to it by exporting the keys provided by Cyclic's &quot;Data/Storage&quot; dashboard to our local machine. (do this every time you launch the terminal)  Cyclic does this automatically for us in production-mode, however. So we don't need to worry about this task when deploying our API. Remember when we mentioned Node's package manager (NPM) that we used to get access to Express? Well, GitHub repositories that use NPM only contain the names and versions of used packages, but not the actual packages themselves. Whenever we clone a GitHub repository, we must run npm install to actually download those packages into our machine. "},{"title":"Our database is empty… let's create some mock data​","type":1,"pageTitle":"Getting Started with a RESTful API","url":"/tutorials/rest-api-and-dynamodb/part-1#our-database-is-empty-lets-create-some-mock-data","content":" Before we get started, it's important to note that every AWS DynamoDB instance has a specific name, also known as a table name. It's given to us by Cyclic in its database dashboard page.  Let's copy that value into the .env.sample file and remove the BUCKET variable. Such a file contains environment variables that must be registered before running our server. However, it won't work until we copy it into a .env file: Learn more about environment variables. cp env.sample .env  The database credentials that we copied into our machine are themselves environment variables. However, we didn't copy them into our .env file since they're only temporary for our local development, and Cyclic will change them once deployed on the Internet. The table name, however, is static and won't change; it's okay to put it in the .env file. After doing that, we can start our REST API by running npm run dev. Let's make sure that our local server is up and running by debugging it using cURL: curl http://localhost:3000/bikes/hybrid%20bike \\ --data '{&quot;title&quot;: &quot;Hybrid Bicycle Sentra&quot;, &quot;vendor&quot;: &quot;Audi&quot;}' \\ -XPOST -H 'Content-Type: application/json'| jq .  As you can see, local servers are hosted on the localhost domain or 127.0.0.1 IP address. It's also common to see them running on the 3000 port, as being done in this server. (8000, 8080, 5000 are also equally as common) Learn more about local hosting and ports.  Our database is currently empty, and it's not very convenient to create API routes that fetch data when… well, there's no data to fetch! That would make it nearly impossible to debug our RESTful API. Therefore, for the purposes of this tutorial, you can run the following script that generates some mock data to fill your database. Create a new file called fill-db.js and copy the contents of this script into it: import DynamoDb from &quot;cyclic-dynamodb&quot;; import slugify from &quot;slugify&quot;; import { v4 as uuidv4 } from &quot;uuid&quot;; import { faker } from &quot;@faker-js/faker&quot;; export const bikeAccessor = () =&gt; { const type = faker.vehicle.bicycle(); const title = type + &quot; &quot; + faker.vehicle.model(); const handle = slugify(title).toLocaleLowerCase(); const minPrice = faker.datatype.number({ min: 800, max: 3000, }); const maxPrice = faker.datatype.number({ min: minPrice, max: minPrice * 2, }); return { id: uuidv4(), title, handle, productType: type, createdAt: String(faker.datatype.datetime()), description: faker.lorem.paragraph(), vendor: faker.vehicle.manufacturer(), availableForSale: faker.datatype.boolean(), totalInventory: faker.datatype.number({ min: 1, max: 5 }), priceRange: { minPrice: { amount: minPrice, currencyCode: &quot;USD&quot;, }, maxPrice: { amount: maxPrice, currencyCode: &quot;USD&quot;, }, }, }; }; async function fillDataBaseWithBikes() { const totalBikes = 25; const randomBikes = Array(totalBikes).fill({}).map(bikeAccessor); const db = DynamoDb(process.env.DYNAMO_DB); const bikesCollection = db.collection(&quot;bikes&quot;); await Promise.allSettled( randomBikes.map((bike) =&gt; bikesCollection.set(bike.id, bike)) ); console.log(`Added ${totalBikes} new bikes.`); } fillDataBaseWithBikes();  Link to full code. Don't worry if you don't understand what this script is doing; we'll be going over all its intricate parts in the rest of this tutorial. Run the following commands to execute this script: npm install slugify uuid @faker-js/faker runtypes jsonwebtoken npx env-cmd node fill-db.js  As you can see, it added 25 bike items to our database. We&quot;ll see how to access all this data in the next section of this guide. caution If you encounter an ExpiredToken error, just refresh Cyclic's page and export the new credentials. In the next part of this series, we'll build the functionality that allows our API to fetch data from this database. "},{"title":"Creating routes to fetch and search data","type":0,"sectionRef":"#","url":"/tutorials/rest-api-and-dynamodb/part-2","content":"","keywords":""},{"title":"Fetching all bikes​","type":1,"pageTitle":"Creating routes to fetch and search data","url":"/tutorials/rest-api-and-dynamodb/part-2#fetching-all-bikes","content":"Our very first route handler is pretty simple: it's a handler for the /bikes/all URL with the GET action, always returning a list of all bikes in the database. tip In large APIs that depend on huge databases (such as Instagram and Twitter), it's common to see support for pagination, a feature that allows the API's users to only fetch part of the database. (since it's nearly impossible to return a list of one million items in just one HTTP response, for example.) We haven't created a route handler, yet. Thankfully, all of them generally follow the same pattern: router.get(&quot;/all&quot;, async (req, res) =&gt; { res.send([]); });  Link to full code. As you can see, we're telling Express to handle the GET action on the /all route by running the router.get method. If we wished to support the POST action instead for example, we would do router.post, as we'll see in the next section of this guide. Route handlers also take a callback function as their second parameter; that's a function that takes two parameters itself: HTTP Request: as the first parameter passed to this function (which we conveniently named req), it's an object that contains all kinds of information about the HTTP request including but not limited to the query strings, body data and even HTTP headers.HTTP Response: this is the second parameter, and it's used to fill the HTTP response with some information before sending it back to the client using the res.send method. For now, we're simply returning an empty Array, but we'll soon populate it with bikes data. And notice how we're using an asynchronous function as the callback. While not required, it's important to note that it's well-supported with Express and we'll be using it to wait for DynamoDB to return its data. Of course, we could also use Promises instead. It's time to start making calls to our DynamoDB instance to actually fetch some data. Let's get started by creating an instance of our bikes collection, giving us access to a variety of methods for manipulating our database: // Initialize AWS DynamoDB const db = DynamoDb(process.env.CYCLIC_DB); const bikesCollection = db.collection(&quot;bikes&quot;);  Link to full code. As you can see, we're using the cyclic-dynamodb library to create a programmable instance of our database. That's a convenience library used to facilitate the communication with our database using simple JavaScript code. We're also extracting the CYCLIC_DB environment variable that we set earlier using process.env. Let's move back into our route handler to finally make some use of this bikesCollection object: // Get all bikes router.get(&quot;/all&quot;, async (req, res) =&gt; { const { results: bikesMetadata } = await bikesCollection.list(); const bikes = await Promise.all( bikesMetadata.map(async ({ key }) =&gt; (await bikesCollection.get(key)).props) ); res.send(bikes); });  Link to full code. Let's dissect the above code snippet line-by-line: We're calling the asynchronous list() method that returns an object containing the results field. Being the only interesting field, we're directly extracting it using JavaScript Destructing Assignment and renaming it to bikesMetadata. This final object, however, does not contain the bike's data; it's only giving us the IDs (or &quot;Keys&quot;) of those bikes. const { results: bikesMetadata } = await bikesCollection.list(); // bikesMetadata = [ // { key: '...' }, // { key: '...' }, // ] We're iterating over every bike key and using the asynchronous get() method to fetch the actual bike data, stored in the props field. The result is an array of Promises, which we await to all be resolved using the Promise.all method. const bikes = await Promise.all( bikesMetadata.map( async ({ key }) =&gt; ( await bikesCollection.get(key) ).props // { props: { ... } } ) // { title, inStock, ... } (actually a Promise!) ); We're finally sending an array of bike data back in the HTTP response. All looking good! Since our server is automatically restarted when we change our code (a consequence of running nodemon), we can directly go debug it using cURL: curl http://localhost:3000/bikes/all | jq .   "},{"title":"Fetching a bike by ID​","type":1,"pageTitle":"Creating routes to fetch and search data","url":"/tutorials/rest-api-and-dynamodb/part-2#fetching-a-bike-by-id","content":"We just figured out how to fetch a full list of bikes using DynamoDB, but within that piece of code, we nested a little snippet that fetched a bike using its ID (or key): await bikesCollection.get(key).props;  We'll be using that command to build the remainder of this route. But first of all, it's important to first model our URL. Since our API follows the REST standard, it's best practice to name it like the following: /bikes/&lt;ID&gt;. As you can see, the ID is encoded directly in the URL itself, so how do we tell Express to extract this specific part of the URL? The answer is relatively simple: when using Express, all we have to do is simply replace the dynamic part of the URL with a colon and give it a name. // Get bike by ID router.get(&quot;/:id&quot;, async (req, res) =&gt; { const id = req.params.id; });  Link to full code. As you can see, we're inserting :id into our URL and proceed to extract it from the req.params object. With the ID now in our hands, we can use that code snippet we just saw to extract specific data from DynamoDB: // Get bike by ID router.get(&quot;/:id&quot;, async (req, res) =&gt; { const id = req.params.id; const { props: bike } = await bikesCollection.get(id); res.send(bike); });  Link to full code. Let's test that: curl http://localhost:3000/bikes/&lt;ID&gt; | jq . # replace &lt;ID&gt; with an ID from the response to /all   But what if the item with that ID doesn't exist? In that case, we wish to return an HTTP response with the 404 status code, indicating that the resource does not exist. // Get bike by ID router.get(&quot;/:id&quot;, async (req, res) =&gt; { const id = req.params.id; try { const { props: bike } = await bikesCollection.get(id); res.send(bike); } catch (e) { console.log(`GET /${id}`, e.message); res.sendStatus(404); } });  Link to full code. Let's see if that works: curl http://localhost:3000/bikes/blahblah   "},{"title":"Fetching a bike by handle​","type":1,"pageTitle":"Creating routes to fetch and search data","url":"/tutorials/rest-api-and-dynamodb/part-2#fetching-a-bike-by-handle","content":"Okay, so we're using IDs to index our bike items. But they're just a random mix of numbers and letters, designed to generate a unique ID per item. The alternative is &quot;handles&quot;, slugified versions of the title that are still unique. Let's extract them from the route: // Get bike by handle router.get(&quot;/by-handle/:handle&quot;, async (req, res) =&gt; { const handle = req.params.handle; });  Link to full code. We can't just run the get() method this time, since we don't have the item's key. One thing we could do, of course, is to get a list of every bike item and check the handle of each one. That, however, is not very efficient. Thankfully, we can use Cyclic's DynamoDB object to filter the bike items and only keep the ones that match our handle: const { results } = await bikesCollection.filter({ handle });  This method, unlike list(), returns the full data for each found item. Let's extract our bike's data and send it back to the client: // Get bike by handle router.get(&quot;/by-handle/:handle&quot;, async (req, res) =&gt; { const handle = req.params.handle; const { results } = await bikesCollection.filter({ handle }); const { props: bike } = results[0]; res.send(bike); });  Link to full code. And let's not forget to do some error handling in case no bike object matches that particular handle. That's tested by checking the truthiness of results.length, returning False when it's an empty array. // Get bike by handle router.get(&quot;/by-handle/:handle&quot;, async (req, res) =&gt; { const handle = req.params.handle; try { const { results } = await bikesCollection.filter({ handle }); if (!results.length) throw new Error(); const { props: bike } = results[0]; res.send(bike); } catch (e) { console.log(`GET /bikes/by-handle/${handle}`, e.message); res.sendStatus(404); } });  Link to full code. And of course, we should always battle-test our API before shipping it to the Internet: curl http://localhost:3000/bikes/by-handle/&lt;HANDLE&gt; | jq . # replace &lt;HANDLE&gt; with a handle from the response to /all   "},{"title":"Fetching bikes by search on title​","type":1,"pageTitle":"Creating routes to fetch and search data","url":"/tutorials/rest-api-and-dynamodb/part-2#fetching-bikes-by-search-on-title","content":"Search is one of the most important features in a website. It's how users discover new products without having to browse a list of hundreds or even thousands of items. Implementing it, however, is not so simple. The most popular search engines have to take a plethora of things into account: ignoring pronouns and uppercase characters, handling misspelled words, etc… In fact, DynamoDB comes with full support for ElasticSearch, a powerful search engine developed used by some of the biggest applications out there. But for the purposes of this tutorial, we'll stick with something more simple. DynamoDB also supports scans: SQL-like querying that handles many powerful expressions. Scans take-in expressions: powerful combinations of built-in commands, such as contains. That's a command that facilitates the ability to check whether one of an item's fields contains a string of characters. Unfortunately, it does not support any advanced search-like features such as ignoring uppercase or lowercase characters, but it's useful enough for a simple application. But before we delve deeper into DynamoDB Scans, let's write the fundamentals of our new router. We'll be using query strings this time, also called GET parameters. They simply are key-value pairs encoded in the right-hand side of a URL in the following manner: /bikes/search/by-title?term=&lt;QUERY&gt; (in this case, &quot;term&quot; is the GET parameter with the value &lt;TERM&gt;) // Search bikes by title router.get(&quot;/search/by-title&quot;, async (req, res) =&gt; { const term = req.query.term || &quot;&quot;; });  Link to full code. Let's proceed now by using this search term to look-up some data. The function that we're looking for is parallel_scan, taking the expression contains(title, &lt;TERM&gt;). However, we must split this expression into its three parts: The expression itself: contains()The attribute name: titleThe attribute value: &lt;TERM&gt; We can combine these 3 parts into one by replacing the attribute name with #title and its value with :value, we can then replace these placeholders with the real values: const { results } = await bikesCollection.parallel_scan({ expression: &quot;contains(#title, :title)&quot;, attr_names: { &quot;#title&quot;: &quot;title&quot;, }, attr_vals: { &quot;:title&quot;: query, }, });  Link to full code. Let's see how that fits into the router code: // Search bikes by title router.get(&quot;/search/by-title&quot;, async (req, res) =&gt; { const query = req.query.query || &quot;&quot;; const { results } = await bikesCollection.parallel_scan({ expression: &quot;contains(#title, :title)&quot;, attr_names: { &quot;#title&quot;: &quot;title&quot;, }, attr_vals: { &quot;:title&quot;: query, }, }); const bikes = results.map(({ props }) =&gt; props); res.send(bikes); });  Link to full code. And with the same error handling, it's even more robust: // Search bikes by title router.get(&quot;/search/by-title&quot;, async (req, res) =&gt; { const query = req.query.query || &quot;&quot;; try { const { results } = await bikesCollection.parallel_scan({ expression: &quot;contains(#title, :title)&quot;, attr_names: { &quot;#title&quot;: &quot;title&quot;, }, attr_vals: { &quot;:title&quot;: query, }, }); const bikes = results.map(({ props }) =&gt; props); res.send(bikes); } catch (e) { console.log(`GET /bikes/search/by-title term=&quot;${query}&quot;`, e.message); res.sendStatus(400); } });  Link to full code. Let's try it out! Make a search with the term &quot;Bicycle&quot; (case-sensitive) and see the results: curl http://localhost:3000/bikes/search/by-title\\?query\\=Bicycle | jq .   In the next part of this series, we'll add more functionality that gives us the ability to create and replace data in the bikes database. "},{"title":"Finishing up with routes to update and delete data","type":0,"sectionRef":"#","url":"/tutorials/rest-api-and-dynamodb/part-4","content":"","keywords":""},{"title":"Updating parts of a bike item​","type":1,"pageTitle":"Finishing up with routes to update and delete data","url":"/tutorials/rest-api-and-dynamodb/part-4#updating-parts-of-a-bike-item","content":"As always, we'll of course get started by extracting data from the HTTP request: // Patch bike if it exists router.patch(&quot;/:id&quot;, async (req, res) =&gt; { const bikeId = req.params.id; const newData = req.body || {}; });  Link to full code. Next step is to check whether or not a bike item with this ID exists, before we update anything. // Patch bike if it exists router.patch(&quot;/:id&quot;, async (req, res) =&gt; { const bikeId = req.params.id; const newData = req.body || {}; try { const { props: oldBike } = await bikesCollection.get(bikeId); } catch (e) { console.log(`PATH /bikes/${bikeId}`, e.message); res.sendStatus(404); } });  Link to full code. After that, we may take advantage of DynamoDB's UpdateItem command to only replace parts of our bike item: // Save new bike object await bikesCollection.set(bikeId, newData);  Link to full code. Let's finish up by sending the full bike object back to the client. We'll take advantage of JavaScript Spread Syntax to create that object: const bike = { ...oldBike, ...newData, }; res.send(bike);  Link to full code. And again, let's try it out: // request.json (remove this line from the actual file!) { &quot;totalInventory&quot;: 4, &quot;availableForSale&quot;: true }  curl -X PATCH -H &quot;Content-Type: application/json&quot; http://localhost:3000/bikes/&lt;ID&gt; -d @request.json | jq . # replace &lt;ID&gt; with an ID from the response to /all   "},{"title":"Deleting a bike item​","type":1,"pageTitle":"Finishing up with routes to update and delete data","url":"/tutorials/rest-api-and-dynamodb/part-4#deleting-a-bike-item","content":"It wouldn't be a big stretch to say that this is the simplest route of the bunch. First step is to get the ID from the route parameters: // Delete bike if it exists router.delete(&quot;/:id&quot;, async (req, res) =&gt; { const bikeId = req.params.id; });  Link to full code. Following that, we quite simply call one function from Cyclic's DynamoDB library and the job's done! await bikesCollection.delete(bikeId);  Link to full code. We'll do some error handling too and return the deleted item's ID back to the client: // Delete bike if it exists router.delete(&quot;/:id&quot;, async (req, res) =&gt; { const bikeId = req.params.id; try { await bikesCollection.delete(bikeId); res.send({ id: bikeId, }); } catch (e) { console.log(`DELETE /bikes/${bikeId}`, e.message); res.sendStatus(404); } });  Link to full code. Let's try deleting some data. Make sure to get the ID from your previous calls to /bikes/all: curl -X DELETE http://localhost:3000/bikes/&lt;ID&gt; | jq . # replace &lt;ID&gt; with an ID from the response to /all   In the final part of this series, we'll add authentication to our API to secure access to the bikes database. "},{"title":"Creating routes to create and replace data","type":0,"sectionRef":"#","url":"/tutorials/rest-api-and-dynamodb/part-3","content":"","keywords":""},{"title":"Creating a new bike​","type":1,"pageTitle":"Creating routes to create and replace data","url":"/tutorials/rest-api-and-dynamodb/part-3#creating-a-new-bike","content":"Our RESTful API should have an endpoint that accepts bike data, with all of its fields except for the ID and handle, which will be both automatically generated within our server. It's worth noting that POST body data can be in a variety of data-types, hinted in the Accept HTTP header. But having declared app.use(express.json()) in our index.js file (it already came with the starter), we can directly access the body data in JSON format by extracting it from the req.body property. // Post new bike router.post(&quot;/&quot;, authenticateUser, async (req, res) =&gt; { const bikeData = req.body; });  Link to full code. Then, it's critical to validate this data. Instead of checking the existence of every field and its value, we can use runtypes, yet another library whose purpose is to conveniently check the fields of an object. import { Record, String, Number, Boolean } from &quot;runtypes&quot;; // Type for new bikes const Money = Record({ amount: Number, currencyCode: String, }); const PriceRange = Record({ minPrice: Money, maxPrice: Money, }); const BikeData = Record({ title: String, productType: String, createdAt: String, description: String, vendor: String, availableForSale: Boolean, totalInventory: Number, priceRange: PriceRange, });  Link to full code. We can now check the validity of our data by calling one simple method: // Create new bike router.post(&quot;/&quot;, async (req, res) =&gt; { const bikeId = req.params.id; const bikeData = req.body; try { // Make sure bike data exists if (!req.body) { throw new Error(); } // Make sure bike data contains all required fields const bikeObject = BikeData.check(bikeData); } catch (e) { console.log(`POST /bikes/`, e.message); res.sendStatus(400); } });  Link to full code. And before saving this data, we must generate its ID and handle. We'll do the former using uuid, a JavaScript library that generates Universally Unique IDentifiers, which are guaranteed to be unique every time. The latter, however, will be done using slugify, a function that strips text from spaces and replaces it with dashes instead: &quot;Mountains Bike&quot; ↦ &quot;Mountains-Bike&quot;. import slugify from &quot;slugify&quot;; import { v4 as uuidv4 } from &quot;uuid&quot;; // Generate ID and Handle for bike const bikeId = uuidv4(); const bikeHandle = slugify(bikeObject.title).toLowerCase(); // Create full bike object const bike = { ...bikeObject, id: bikeId, handle: bikeHandle, };  Link to full code. And the last step of course is to save this data and send it back to the client. This time, the client will receive a bike object with the ID and handle included: // Save bike object await bikesCollection.set(bikeId, bike); res.send(bike);  Link to full code. Let's try it out! We'll use cURL to read request.json as body data by prefixing it with an @ symbol. // request.json (remove this line from the actual file!) { &quot;productType&quot;: &quot;Hybrid Bicycle&quot;, &quot;createdAt&quot;: &quot;Fri Jan 28 2022 03:13:24 GMT+0100 (GMT+02:00)&quot;, &quot;vendor&quot;: &quot;Audi&quot;, &quot;totalInventory&quot;: 2, &quot;availableForSale&quot;: false, &quot;priceRange&quot;: { &quot;minPrice&quot;: { &quot;currencyCode&quot;: &quot;USD&quot;, &quot;amount&quot;: 1160 }, &quot;maxPrice&quot;: { &quot;currencyCode&quot;: &quot;USD&quot;, &quot;amount&quot;: 1624 } }, &quot;description&quot;: &quot;Autem ipsam quasi omnis ut. Et officiis quia. Sed quaerat pariatur nihil nobis est quos earum quidem.&quot;, &quot;title&quot;: &quot;Hybrid Bicycle Sentra&quot; }  curl -H &quot;Content-Type: application/json&quot; http://localhost:3000/bikes/ -d @request.json | jq .   "},{"title":"Replacing a bike item​","type":1,"pageTitle":"Creating routes to create and replace data","url":"/tutorials/rest-api-and-dynamodb/part-3#replacing-a-bike-item","content":"Another common RESTful API endpoint that we must implement is PUT, whose purpose is to replace a bike item instead of creating it. This time, the ID and handle will be already provided, so we don't have to do much instead of validating the data. // Update entire bike router.put(&quot;/:id&quot;, async (req, res) =&gt; { const bikeId = req.params.id; const bikeData = req.body; try { // Make sure bike data exists if (!req.body) { throw new Error(); } // Make sure bike has ID and handle if (!bikeData.id || !bikeData.handle) { throw new Error(); } // Make sure bike data contains all required fields const bikeObject = BikeData.check(bikeData); // Delete existing bike object await bikesCollection.delete(bikeId); // Save new bike object await bikesCollection.set(bikeId, bikeObject); res.send(bikeObject); } catch (e) { console.log(`PUT bikes/${bikeId}`, e.message); res.sendStatus(404); } });  Link to full code. What we're doing here is first checking if the bike item exists by retrieving its ID, and we're then validating the data, deleting the existing item and replacing it with a new item. // request.json (remove this line from the actual file!) { &quot;productType&quot;: &quot;Hybrid Bicycle&quot;, &quot;createdAt&quot;: &quot;Fri Jan 28 2022 03:13:24 GMT+0100 (GMT+02:00)&quot;, &quot;vendor&quot;: &quot;Audi&quot;, &quot;totalInventory&quot;: 2, &quot;availableForSale&quot;: false, &quot;priceRange&quot;: { &quot;minPrice&quot;: { &quot;currencyCode&quot;: &quot;USD&quot;, &quot;amount&quot;: 1160 }, &quot;maxPrice&quot;: { &quot;currencyCode&quot;: &quot;USD&quot;, &quot;amount&quot;: 1624 } }, &quot;description&quot;: &quot;Autem ipsam quasi omnis ut. Et officiis quia. Sed quaerat pariatur nihil nobis est quos earum quidem.&quot;, &quot;title&quot;: &quot;Hybrid Bicycle Sentra&quot;, &quot;id&quot;: &quot;4139c5ae-b83d-4a0c-9b75-12d182aaed7c&quot;, &quot;handle&quot;: &quot;hybrid-bicycle-sentra&quot; }  curl -X PUT -H &quot;Content-Type: application/json&quot; http://localhost:3000/bikes/&lt;ID&gt; -d @request.json | jq . # replace &lt;ID&gt; with an ID from the response to /all   In the next part of this series, we'll build the functionality that allows our API to delete and update data in the bikes database. "},{"title":"Securing our database with authentication and Deploying our API to the web","type":0,"sectionRef":"#","url":"/tutorials/rest-api-and-dynamodb/part-5","content":"","keywords":""},{"title":"Securing our database with authentication​","type":1,"pageTitle":"Securing our database with authentication and Deploying our API to the web","url":"/tutorials/rest-api-and-dynamodb/part-5#securing-our-database-with-authentication","content":" Every public (and private) API must come with some sort of protection around its data. We mustn't allow anyone in the world to poke around our important database. And while there are various authentication methods out there, Bearer is one of the simplest. It's quite simple: we give users a token (they're the bearer of that token), we give that token some privileges (such as only reading or also writing and deleting) and finally we require the use of that token when making unsafe HTTP requests. We won't be implementing privileges and roles to keep this guide simple, but we'll be using Bearer authentication. Get started by installing the jsonwebtoken package; it's an implementation of JSON Web Tokens, an standard for creating and checking credentials across the Internet. After that, create an auth.js file, which will contain two important utilities for Bearer authentication. The first one is an Express middleware that's run before every route handler we desire. It's there to help us avoid repetition, so we can instead write all the authentication logic in one function and not worry about it anymore. We expect auth-enabled routes to receive an Authorization HTTP header containing a value in the form Bearer &lt;TOKEN&gt;, so let's start by extracting the &lt;TOKEN&gt;: // auth.js import jwt from &quot;jsonwebtoken&quot;; export function authenticateUser(req, res, next) { const authHeader = req.headers[&quot;authorization&quot;]; const bearerToken = authHeader &amp;&amp; authHeader.split(&quot; &quot;)[1]; if (!bearerToken) { res.sendStatus(401); // 401 UNAUTHORIZED } }  Link to full code. We'll proceed by verifying the validity of this token using the verify() method. But before we do that, it's important to note that Bearer authentication depends on one secret stored in the environment variables. With this secret value, Bearer tokens are both generated and verified. Let's create our token by running the following command: // generate-secret.js require(&quot;crypto&quot;).randomBytes(64).toString(&quot;hex&quot;);  node generate-secret.js   Copy that token and paste it in your .env file with the key name: &quot;TOKEN_SECRET&quot;. Let's delve back into our code: if (!bearerToken) { res.sendStatus(401); } else { jwt.verify(bearerToken, process.env.TOKEN_SECRET, (err, user) =&gt; { if (err) { console.log(err); res.sendStatus(403); // 403 FORBIDDEN } else { req.user = user; next(); } }); }  Link to full code. Every Express middleware is handed a next() function, which is simply called to run the default route handler. We're calling it when there's no error with verification, meaning that the Bearer token is correct. Let's go back into our router code and add this middleware to all our unsafe HTTP method handlers: import { authenticateUser } from &quot;./auth.js&quot;; router.post(&quot;/&quot;, authenticateUser, ... ) router.put(&quot;/:id&quot;, authenticateUser, ... ) router.patch(&quot;/:id&quot;, authenticateUser, ... ) router.delete(&quot;/:id&quot;, authenticateUser, ... )  Link to full code. And yes, the second parameter just became the middlware function, while the route handler was pushed to the next position. This is totally possible because JavaScript supports a clever workaround for overloading, a programming language feature that allows functions to have the same names but different parameters. Let's try it out now: curl -X DELETE http://localhost:3000/bikes/&lt;ID&gt; # replace &lt;ID&gt; with an ID from the response to /all   Unsurprisingly, we're now getting the 401 UNAUTHORIZED response that we previously programmed when there was no Bearer token in the request. Let's go ahead and add one new route to generate Bearer tokens. This one will directly go into index.js as we don't want it to be prefixed with the bikes/ route. // Create new bearer token app.post(&quot;/api/user&quot;, (req, res) =&gt; { const username = req.body.username; const token = &quot;&quot;; // TODO res.send({ token }); });  Link to full code. We still need a utility function that generated the Bearer tokens. Head back to the auth.js file and add the following: // auth.js export function generateAccessToken(username) { return jwt.sign(username, process.env.TOKEN_SECRET, { expiresIn: &quot;1800s&quot; }); }  Link to full code. As you can see, we're using the same secret to generate our Bearer tokens, and we're also setting them to expire in 30 minutes (or 1800 seconds). We can now finish our token route: import { generateAccessToken } from &quot;./auth.js&quot;; // Create new bearer token app.post(&quot;/api/user&quot;, (req, res) =&gt; { const username = req.body.username; const token = generateAccessToken({ username }); res.send({ token }); });  Link to full code. And with that done, we can easily generate new tokens and use them in our API requests. Restart your server (CTRL+C then npm run dev) and run the following command: curl -H 'Content-Type: application/json' http://localhost:3000/api/user -d '{&quot;username&quot;: &quot;cyclic&quot;}' | jq .token -r  Let's add an &quot;Authorization&quot; header to our new request: export TOKEN=&lt;TOKEN&gt; # replace &lt;TOKEN&gt; with the token from /api/user curl -H &quot;Authorization: Bearer $TOKEN&quot; -X DELETE http://localhost:3000/bikes/&lt;ID&gt; | jq . # replace &lt;ID&gt; with an ID from the response to /all   "},{"title":"Deploying our API to the web, with Cyclic​","type":1,"pageTitle":"Securing our database with authentication and Deploying our API to the web","url":"/tutorials/rest-api-and-dynamodb/part-5#deploying-our-api-to-the-web-with-cyclic","content":"We just created a full-fledged RESTful API that could be used to build an e-commerce store for bikes. Through this journey, we learnt about servers, HTTP, RESTful APIs, AWS DynamoDB and how Cyclic brings all these technologies together into one using its distinct starter templates.   Let's commit all our new changes back into our code repository and let Cyclic automatically deploy these new changes to the web. We can track this process in Cylic's Deployments dashboard.  And since .env files are not committed publicly to GitHub repositories (since they're supposed to be secret), we must head back to the Cyclic dashboard and manually paste those values.  Furthermore, we can give our API its own custom subdomain, for free! 😃 Our API is now live and we can use it the same way we did when it was running locally on our machine, but this time we'll replace the localhost domain with the server's domain. "},{"title":"Where to go from here​","type":1,"pageTitle":"Securing our database with authentication and Deploying our API to the web","url":"/tutorials/rest-api-and-dynamodb/part-5#where-to-go-from-here","content":"We could still add a variety of endpoints to our API: GETting items by category,advanced searching capabilities using ElasticSearch (it has a free-tier!) and many more things. You can get as creative as you want with it, you'll only be learning new things along the way! Get inspired by the plethora of public APIs out there, attempt rebuilding them while adding your own personal touch, deploy them on Cyclic and you'll soon be the one teaching all this stuff! 💪 "}]